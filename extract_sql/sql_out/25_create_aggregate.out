CREATE AGGREGATE newavg (  sfunc = int4_avg_accum, basetype = int4, stype = _int8,  finalfunc = int8_avg,  initcond1 = '{0,0}'  );
COMMENT ON AGGREGATE newavg_wrong (int4) IS 'an agg comment';
COMMENT ON AGGREGATE newavg (int4) IS 'an agg comment';
COMMENT ON AGGREGATE newavg (int4) IS NULL;
CREATE AGGREGATE newsum (  sfunc1 = int4pl, basetype = int4, stype1 = int4,  initcond1 = '0'  );
CREATE AGGREGATE newcnt (*) (  sfunc = int8inc, stype = int8,  initcond = '0'  );
CREATE AGGREGATE oldcnt (  sfunc = int8inc, basetype = 'ANY', stype = int8,  initcond = '0'  );
CREATE AGGREGATE newcnt ("any") (  sfunc = int8inc_any, stype = int8,  initcond = '0'  );
COMMENT ON AGGREGATE nosuchagg (*) IS 'should fail';
COMMENT ON AGGREGATE newcnt (*) IS 'an agg(*) comment';
COMMENT ON AGGREGATE newcnt ("any") IS 'an agg(any) comment';
create function sum3(int8,int8,int8) returns int8 as  'select $1 + $2 + $3' language sql strict immutable;
create aggregate sum2(int8,int8) (  sfunc = sum3, stype = int8,  initcond = '0'  );
create type aggtype as (a integer, b integer, c text);
create function aggf_trans(aggtype[],integer,integer,text) returns aggtype[]  as 'select array_append($1,ROW($2,$3,$4)::aggtype)'  language sql strict immutable;
create function aggfns_trans(aggtype[],integer,integer,text) returns aggtype[] as 'select array_append($1,ROW($2,$3,$4)::aggtype)'  language sql immutable;
create aggregate aggfstr(integer,integer,text) (  sfunc = aggf_trans, stype = aggtype[],  initcond = '{}'  );
create aggregate aggfns(integer,integer,text) (  sfunc = aggfns_trans, stype = aggtype[], sspace = 10000,  initcond = '{}'  );
create function least_accum(anyelement, variadic anyarray)  returns anyelement language sql as  'select least($1, min($2[i])) from generate_subscripts($2,1) g(i)';
create aggregate least_agg(variadic items anyarray) (  stype = anyelement, sfunc = least_accum  );
create aggregate my_percentile_disc(float8 ORDER BY anyelement) (  stype = internal,  sfunc = ordered_set_transition,  finalfunc = percentile_disc_final,  finalfunc_extra = true  );
create aggregate my_rank(VARIADIC "any" ORDER BY VARIADIC "any") (  stype = internal,  sfunc = ordered_set_transition_multi,  finalfunc = rank_final,  finalfunc_extra = true,  hypothetical  );
alter aggregate my_percentile_disc(float8 ORDER BY anyelement)  rename to test_percentile_disc;
alter aggregate my_rank(VARIADIC "any" ORDER BY VARIADIC "any")  rename to test_rank;
SELECT n.nspname as "Schema",  p.proname AS "Name",  pg_catalog.format_type(p.prorettype, NULL) AS "Result data type",  CASE WHEN p.pronargs = 0  THEN CAST('*' AS pg_catalog.text)  ELSE pg_catalog.pg_get_function_arguments(p.oid)  END AS "Argument data types",  pg_catalog.obj_description(p.oid, 'pg_proc') as "Description"  FROM pg_catalog.pg_proc p  LEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace  WHERE p.proisagg  AND p.proname ~ '^(test_.*)$'  AND pg_catalog.pg_function_is_visible(p.oid)  ORDER BY 1, 2, 4;
CREATE AGGREGATE sumdouble (float8)  (  stype = float8,  sfunc = float8pl,  mstype = float8,  msfunc = float8pl,  minvfunc = float8mi  );
CREATE FUNCTION float8mi_n(float8, float8) RETURNS float8 AS  $$ SELECT $1 - $2; $$  LANGUAGE SQL;
CREATE AGGREGATE invalidsumdouble (float8)  (  stype = float8,  sfunc = float8pl,  mstype = float8,  msfunc = float8pl,  minvfunc = float8mi_n  );
CREATE FUNCTION float8mi_int(float8, float8) RETURNS int AS  $$ SELECT CAST($1 - $2 AS INT); $$  LANGUAGE SQL;
CREATE AGGREGATE wrongreturntype (float8)  (  stype = float8,  sfunc = float8pl,  mstype = float8,  msfunc = float8pl,  minvfunc = float8mi_int  );
