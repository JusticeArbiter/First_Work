/* Test inheritance of structure (LIKE) */  CREATE TABLE inhx (xx text DEFAULT 'text');
/*  * Test double inheritance  *  * Ensure that defaults are NOT included unless  * INCLUDING DEFAULTS is specified  */  CREATE TABLE ctla (aa TEXT);
CREATE TABLE ctlb (bb TEXT) INHERITS (ctla);
CREATE TABLE foo (LIKE nonexistent);
CREATE TABLE inhe (ee text, LIKE inhx) inherits (ctlb);
INSERT INTO inhe VALUES ('ee-col1', 'ee-col2', DEFAULT, 'ee-col4');
SELECT * FROM inhe;
/* Columns aa, bb, xx value NULL, ee */  SELECT * FROM inhx;
/* Empty set since LIKE inherits structure only */  SELECT * FROM ctlb;
/* Has ee entry */  SELECT * FROM ctla;
/* Has ee entry */  CREATE TABLE inhf (LIKE inhx, LIKE inhx);
/* Throw error */  CREATE TABLE inhf (LIKE inhx INCLUDING DEFAULTS INCLUDING CONSTRAINTS);
INSERT INTO inhf DEFAULT VALUES;
SELECT * FROM inhf;
/* Single entry with value 'text' */  ALTER TABLE inhx add constraint foo CHECK (xx = 'text');
ALTER TABLE inhx ADD PRIMARY KEY (xx);
CREATE TABLE inhg (LIKE inhx);
/* Doesn't copy constraint */  INSERT INTO inhg VALUES ('foo');
DROP TABLE inhg;
CREATE TABLE inhg (x text, LIKE inhx INCLUDING CONSTRAINTS, y text);
/* Copies constraints */  INSERT INTO inhg VALUES ('x', 'text', 'y');
/* Succeeds */  INSERT INTO inhg VALUES ('x', 'text', 'y');
/* Succeeds -- Unique constraints not copied */  INSERT INTO inhg VALUES ('x', 'foo', 'y');
/* fails due to constraint */  SELECT * FROM inhg;
/* Two records with three columns in order x=x, xx=text, y=y */  DROP TABLE inhg;
CREATE TABLE inhg (x text, LIKE inhx INCLUDING INDEXES, y text);
/* copies indexes */  INSERT INTO inhg VALUES (5, 10);
INSERT INTO inhg VALUES (20, 10);
DROP TABLE inhg;
/* Multiple primary keys creation should fail */  CREATE TABLE inhg (x text, LIKE inhx INCLUDING INDEXES, PRIMARY KEY(x));
/* fails */  CREATE TABLE inhz (xx text DEFAULT 'text', yy int UNIQUE);
CREATE UNIQUE INDEX inhz_xx_idx on inhz (xx) WHERE xx <> 'test';
/* Ok to create multiple unique indexes */  CREATE TABLE inhg (x text UNIQUE, LIKE inhz INCLUDING INDEXES);
INSERT INTO inhg (xx, yy, x) VALUES ('test', 5, 10);
INSERT INTO inhg (xx, yy, x) VALUES ('test', 10, 15);
INSERT INTO inhg (xx, yy, x) VALUES ('foo', 10, 15);
DROP TABLE inhg;
DROP TABLE inhz;
CREATE TABLE ctlt1 (a text CHECK (length(a) > 2) PRIMARY KEY, b text);
CREATE INDEX ctlt1_b_key ON ctlt1 (b);
CREATE INDEX ctlt1_fnidx ON ctlt1 ((a || b));
COMMENT ON COLUMN ctlt1.a IS 'A';
COMMENT ON COLUMN ctlt1.b IS 'B';
COMMENT ON CONSTRAINT ctlt1_a_check ON ctlt1 IS 't1_a_check';
COMMENT ON INDEX ctlt1_pkey IS 'index pkey';
COMMENT ON INDEX ctlt1_b_key IS 'index b_key';
ALTER TABLE ctlt1 ALTER COLUMN a SET STORAGE MAIN;
CREATE TABLE ctlt2 (c text);
ALTER TABLE ctlt2 ALTER COLUMN c SET STORAGE EXTERNAL;
COMMENT ON COLUMN ctlt2.c IS 'C';
CREATE TABLE ctlt3 (a text CHECK (length(a) < 5), c text);
ALTER TABLE ctlt3 ALTER COLUMN c SET STORAGE EXTERNAL;
ALTER TABLE ctlt3 ALTER COLUMN a SET STORAGE MAIN;
COMMENT ON COLUMN ctlt3.a IS 'A3';
COMMENT ON COLUMN ctlt3.c IS 'C';
COMMENT ON CONSTRAINT ctlt3_a_check ON ctlt3 IS 't3_a_check';
CREATE TABLE ctlt4 (a text, c text);
ALTER TABLE ctlt4 ALTER COLUMN c SET STORAGE EXTERNAL;
CREATE TABLE ctlt12_storage (LIKE ctlt1 INCLUDING STORAGE, LIKE ctlt2 INCLUDING STORAGE);
SELECT c.oid,  n.nspname,  c.relname  FROM pg_catalog.pg_class c  LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace  WHERE c.relname ~ '^(ctlt12_storage)$'  AND pg_catalog.pg_table_is_visible(c.oid)  ORDER BY 2, 3;
SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, c.relhasoids, pg_catalog.array_to_string(c.reloptions || array(select 'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ') , c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident  FROM pg_catalog.pg_class c  LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)  WHERE c.oid = '20125';
SELECT a.attname,  pg_catalog.format_type(a.atttypid, a.atttypmod),  (SELECT substring(pg_catalog.pg_get_expr(d.adbin, d.adrelid) for 128)  FROM pg_catalog.pg_attrdef d  WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),  a.attnotnull, a.attnum,  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t  WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,  NULL AS indexdef,  NULL AS attfdwoptions,  a.attstorage,  CASE WHEN a.attstattarget=-1 THEN NULL ELSE a.attstattarget END AS attstattarget, pg_catalog.col_description(a.attrelid, a.attnum)  FROM pg_catalog.pg_attribute a  WHERE a.attrelid = '20125' AND a.attnum > 0 AND NOT a.attisdropped  ORDER BY a.attnum;
SELECT pol.polname,  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),  CASE pol.polcmd  WHEN 'r' THEN 'SELECT'  WHEN 'a' THEN 'INSERT'  WHEN 'w' THEN 'UPDATE'  WHEN 'd' THEN 'DELETE'  WHEN '*' THEN 'ALL'  END AS cmd  FROM pg_catalog.pg_policy pol  WHERE pol.polrelid = '20125' ORDER BY 1;
SELECT c.oid::pg_catalog.regclass FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i WHERE c.oid=i.inhparent AND i.inhrelid = '20125' ORDER BY inhseqno;
SELECT c.oid::pg_catalog.regclass FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i WHERE c.oid=i.inhrelid AND i.inhparent = '20125' ORDER BY c.oid::pg_catalog.regclass::pg_catalog.text;
CREATE TABLE ctlt12_comments (LIKE ctlt1 INCLUDING COMMENTS, LIKE ctlt2 INCLUDING COMMENTS);
SELECT c.oid,  n.nspname,  c.relname  FROM pg_catalog.pg_class c  LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace  WHERE c.relname ~ '^(ctlt12_comments)$'  AND pg_catalog.pg_table_is_visible(c.oid)  ORDER BY 2, 3;
SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, c.relhasoids, pg_catalog.array_to_string(c.reloptions || array(select 'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ') , c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident  FROM pg_catalog.pg_class c  LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)  WHERE c.oid = '20131';
SELECT a.attname,  pg_catalog.format_type(a.atttypid, a.atttypmod),  (SELECT substring(pg_catalog.pg_get_expr(d.adbin, d.adrelid) for 128)  FROM pg_catalog.pg_attrdef d  WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),  a.attnotnull, a.attnum,  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t  WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,  NULL AS indexdef,  NULL AS attfdwoptions,  a.attstorage,  CASE WHEN a.attstattarget=-1 THEN NULL ELSE a.attstattarget END AS attstattarget, pg_catalog.col_description(a.attrelid, a.attnum)  FROM pg_catalog.pg_attribute a  WHERE a.attrelid = '20131' AND a.attnum > 0 AND NOT a.attisdropped  ORDER BY a.attnum;
SELECT pol.polname,  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),  CASE pol.polcmd  WHEN 'r' THEN 'SELECT'  WHEN 'a' THEN 'INSERT'  WHEN 'w' THEN 'UPDATE'  WHEN 'd' THEN 'DELETE'  WHEN '*' THEN 'ALL'  END AS cmd  FROM pg_catalog.pg_policy pol  WHERE pol.polrelid = '20131' ORDER BY 1;
SELECT c.oid::pg_catalog.regclass FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i WHERE c.oid=i.inhparent AND i.inhrelid = '20131' ORDER BY inhseqno;
SELECT c.oid::pg_catalog.regclass FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i WHERE c.oid=i.inhrelid AND i.inhparent = '20131' ORDER BY c.oid::pg_catalog.regclass::pg_catalog.text;
CREATE TABLE ctlt1_inh (LIKE ctlt1 INCLUDING CONSTRAINTS INCLUDING COMMENTS) INHERITS (ctlt1);
SELECT c.oid,  n.nspname,  c.relname  FROM pg_catalog.pg_class c  LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace  WHERE c.relname ~ '^(ctlt1_inh)$'  AND pg_catalog.pg_table_is_visible(c.oid)  ORDER BY 2, 3;
SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, c.relhasoids, pg_catalog.array_to_string(c.reloptions || array(select 'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ') , c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident  FROM pg_catalog.pg_class c  LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)  WHERE c.oid = '20137';
SELECT a.attname,  pg_catalog.format_type(a.atttypid, a.atttypmod),  (SELECT substring(pg_catalog.pg_get_expr(d.adbin, d.adrelid) for 128)  FROM pg_catalog.pg_attrdef d  WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),  a.attnotnull, a.attnum,  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t  WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,  NULL AS indexdef,  NULL AS attfdwoptions,  a.attstorage,  CASE WHEN a.attstattarget=-1 THEN NULL ELSE a.attstattarget END AS attstattarget, pg_catalog.col_description(a.attrelid, a.attnum)  FROM pg_catalog.pg_attribute a  WHERE a.attrelid = '20137' AND a.attnum > 0 AND NOT a.attisdropped  ORDER BY a.attnum;
SELECT r.conname, pg_catalog.pg_get_constraintdef(r.oid, true)  FROM pg_catalog.pg_constraint r  WHERE r.conrelid = '20137' AND r.contype = 'c'  ORDER BY 1;
SELECT pol.polname,  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),  CASE pol.polcmd  WHEN 'r' THEN 'SELECT'  WHEN 'a' THEN 'INSERT'  WHEN 'w' THEN 'UPDATE'  WHEN 'd' THEN 'DELETE'  WHEN '*' THEN 'ALL'  END AS cmd  FROM pg_catalog.pg_policy pol  WHERE pol.polrelid = '20137' ORDER BY 1;
SELECT c.oid::pg_catalog.regclass FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i WHERE c.oid=i.inhparent AND i.inhrelid = '20137' ORDER BY inhseqno;
SELECT c.oid::pg_catalog.regclass FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i WHERE c.oid=i.inhrelid AND i.inhparent = '20137' ORDER BY c.oid::pg_catalog.regclass::pg_catalog.text;
SELECT description FROM pg_description, pg_constraint c WHERE classoid = 'pg_constraint'::regclass AND objoid = c.oid AND c.conrelid = 'ctlt1_inh'::regclass;
CREATE TABLE ctlt13_inh () INHERITS (ctlt1, ctlt3);
SELECT c.oid,  n.nspname,  c.relname  FROM pg_catalog.pg_class c  LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace  WHERE c.relname ~ '^(ctlt13_inh)$'  AND pg_catalog.pg_table_is_visible(c.oid)  ORDER BY 2, 3;
SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, c.relhasoids, pg_catalog.array_to_string(c.reloptions || array(select 'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ') , c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident  FROM pg_catalog.pg_class c  LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)  WHERE c.oid = '20144';
SELECT a.attname,  pg_catalog.format_type(a.atttypid, a.atttypmod),  (SELECT substring(pg_catalog.pg_get_expr(d.adbin, d.adrelid) for 128)  FROM pg_catalog.pg_attrdef d  WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),  a.attnotnull, a.attnum,  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t  WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,  NULL AS indexdef,  NULL AS attfdwoptions,  a.attstorage,  CASE WHEN a.attstattarget=-1 THEN NULL ELSE a.attstattarget END AS attstattarget, pg_catalog.col_description(a.attrelid, a.attnum)  FROM pg_catalog.pg_attribute a  WHERE a.attrelid = '20144' AND a.attnum > 0 AND NOT a.attisdropped  ORDER BY a.attnum;
SELECT r.conname, pg_catalog.pg_get_constraintdef(r.oid, true)  FROM pg_catalog.pg_constraint r  WHERE r.conrelid = '20144' AND r.contype = 'c'  ORDER BY 1;
SELECT pol.polname,  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),  CASE pol.polcmd  WHEN 'r' THEN 'SELECT'  WHEN 'a' THEN 'INSERT'  WHEN 'w' THEN 'UPDATE'  WHEN 'd' THEN 'DELETE'  WHEN '*' THEN 'ALL'  END AS cmd  FROM pg_catalog.pg_policy pol  WHERE pol.polrelid = '20144' ORDER BY 1;
SELECT c.oid::pg_catalog.regclass FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i WHERE c.oid=i.inhparent AND i.inhrelid = '20144' ORDER BY inhseqno;
SELECT c.oid::pg_catalog.regclass FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i WHERE c.oid=i.inhrelid AND i.inhparent = '20144' ORDER BY c.oid::pg_catalog.regclass::pg_catalog.text;
CREATE TABLE ctlt13_like (LIKE ctlt3 INCLUDING CONSTRAINTS INCLUDING COMMENTS INCLUDING STORAGE) INHERITS (ctlt1);
SELECT c.oid,  n.nspname,  c.relname  FROM pg_catalog.pg_class c  LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace  WHERE c.relname ~ '^(ctlt13_like)$'  AND pg_catalog.pg_table_is_visible(c.oid)  ORDER BY 2, 3;
SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, c.relhasoids, pg_catalog.array_to_string(c.reloptions || array(select 'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ') , c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident  FROM pg_catalog.pg_class c  LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)  WHERE c.oid = '20152';
SELECT a.attname,  pg_catalog.format_type(a.atttypid, a.atttypmod),  (SELECT substring(pg_catalog.pg_get_expr(d.adbin, d.adrelid) for 128)  FROM pg_catalog.pg_attrdef d  WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),  a.attnotnull, a.attnum,  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t  WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,  NULL AS indexdef,  NULL AS attfdwoptions,  a.attstorage,  CASE WHEN a.attstattarget=-1 THEN NULL ELSE a.attstattarget END AS attstattarget, pg_catalog.col_description(a.attrelid, a.attnum)  FROM pg_catalog.pg_attribute a  WHERE a.attrelid = '20152' AND a.attnum > 0 AND NOT a.attisdropped  ORDER BY a.attnum;
SELECT r.conname, pg_catalog.pg_get_constraintdef(r.oid, true)  FROM pg_catalog.pg_constraint r  WHERE r.conrelid = '20152' AND r.contype = 'c'  ORDER BY 1;
SELECT pol.polname,  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),  CASE pol.polcmd  WHEN 'r' THEN 'SELECT'  WHEN 'a' THEN 'INSERT'  WHEN 'w' THEN 'UPDATE'  WHEN 'd' THEN 'DELETE'  WHEN '*' THEN 'ALL'  END AS cmd  FROM pg_catalog.pg_policy pol  WHERE pol.polrelid = '20152' ORDER BY 1;
SELECT c.oid::pg_catalog.regclass FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i WHERE c.oid=i.inhparent AND i.inhrelid = '20152' ORDER BY inhseqno;
SELECT c.oid::pg_catalog.regclass FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i WHERE c.oid=i.inhrelid AND i.inhparent = '20152' ORDER BY c.oid::pg_catalog.regclass::pg_catalog.text;
SELECT description FROM pg_description, pg_constraint c WHERE classoid = 'pg_constraint'::regclass AND objoid = c.oid AND c.conrelid = 'ctlt13_like'::regclass;
CREATE TABLE ctlt_all (LIKE ctlt1 INCLUDING ALL);
SELECT c.oid,  n.nspname,  c.relname  FROM pg_catalog.pg_class c  LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace  WHERE c.relname ~ '^(ctlt_all)$'  AND pg_catalog.pg_table_is_visible(c.oid)  ORDER BY 2, 3;
SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, c.relhasoids, pg_catalog.array_to_string(c.reloptions || array(select 'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ') , c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident  FROM pg_catalog.pg_class c  LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)  WHERE c.oid = '20160';
SELECT a.attname,  pg_catalog.format_type(a.atttypid, a.atttypmod),  (SELECT substring(pg_catalog.pg_get_expr(d.adbin, d.adrelid) for 128)  FROM pg_catalog.pg_attrdef d  WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),  a.attnotnull, a.attnum,  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t  WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,  NULL AS indexdef,  NULL AS attfdwoptions,  a.attstorage,  CASE WHEN a.attstattarget=-1 THEN NULL ELSE a.attstattarget END AS attstattarget, pg_catalog.col_description(a.attrelid, a.attnum)  FROM pg_catalog.pg_attribute a  WHERE a.attrelid = '20160' AND a.attnum > 0 AND NOT a.attisdropped  ORDER BY a.attnum;
SELECT c2.relname, i.indisprimary, i.indisunique, i.indisclustered, i.indisvalid, pg_catalog.pg_get_indexdef(i.indexrelid, 0, true),  pg_catalog.pg_get_constraintdef(con.oid, true), contype, condeferrable, condeferred, i.indisreplident, c2.reltablespace  FROM pg_catalog.pg_class c, pg_catalog.pg_class c2, pg_catalog.pg_index i  LEFT JOIN pg_catalog.pg_constraint con ON (conrelid = i.indrelid AND conindid = i.indexrelid AND contype IN ('p','u','x'))  WHERE c.oid = '20160' AND c.oid = i.indrelid AND i.indexrelid = c2.oid  ORDER BY i.indisprimary DESC, i.indisunique DESC, c2.relname;
SELECT r.conname, pg_catalog.pg_get_constraintdef(r.oid, true)  FROM pg_catalog.pg_constraint r  WHERE r.conrelid = '20160' AND r.contype = 'c'  ORDER BY 1;
SELECT pol.polname,  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),  CASE pol.polcmd  WHEN 'r' THEN 'SELECT'  WHEN 'a' THEN 'INSERT'  WHEN 'w' THEN 'UPDATE'  WHEN 'd' THEN 'DELETE'  WHEN '*' THEN 'ALL'  END AS cmd  FROM pg_catalog.pg_policy pol  WHERE pol.polrelid = '20160' ORDER BY 1;
SELECT c.oid::pg_catalog.regclass FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i WHERE c.oid=i.inhparent AND i.inhrelid = '20160' ORDER BY inhseqno;
SELECT c.oid::pg_catalog.regclass FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i WHERE c.oid=i.inhrelid AND i.inhparent = '20160' ORDER BY c.oid::pg_catalog.regclass::pg_catalog.text;
SELECT c.relname, objsubid, description FROM pg_description, pg_index i, pg_class c WHERE classoid = 'pg_class'::regclass AND objoid = i.indexrelid AND c.oid = i.indexrelid AND i.indrelid = 'ctlt_all'::regclass ORDER BY c.relname, objsubid;
CREATE TABLE inh_error1 () INHERITS (ctlt1, ctlt4);
CREATE TABLE inh_error2 (LIKE ctlt4 INCLUDING STORAGE) INHERITS (ctlt1);
DROP TABLE ctlt1, ctlt2, ctlt3, ctlt4, ctlt12_storage, ctlt12_comments, ctlt1_inh, ctlt13_inh, ctlt13_like, ctlt_all, ctla, ctlb CASCADE;
/* LIKE with other relation kinds */  CREATE TABLE ctlt4 (a int, b text);
CREATE SEQUENCE ctlseq1;
CREATE TABLE ctlt10 (LIKE ctlseq1);
CREATE VIEW ctlv1 AS SELECT * FROM ctlt4;
CREATE TABLE ctlt11 (LIKE ctlv1);
CREATE TABLE ctlt11a (LIKE ctlv1 INCLUDING ALL);
CREATE TYPE ctlty1 AS (a int, b text);
CREATE TABLE ctlt12 (LIKE ctlty1);
DROP SEQUENCE ctlseq1;
DROP TYPE ctlty1;
DROP VIEW ctlv1;
DROP TABLE IF EXISTS ctlt4, ctlt10, ctlt11, ctlt11a, ctlt12;
