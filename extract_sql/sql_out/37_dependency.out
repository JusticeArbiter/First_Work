CREATE USER regression_user;
CREATE USER regression_user2;
CREATE USER regression_user3;
CREATE GROUP regression_group;
CREATE TABLE deptest (f1 serial primary key, f2 text);
GRANT SELECT ON TABLE deptest TO GROUP regression_group;
GRANT ALL ON TABLE deptest TO regression_user, regression_user2;
DROP USER regression_user;
DROP GROUP regression_group;
REVOKE SELECT ON deptest FROM GROUP regression_group;
DROP GROUP regression_group;
REVOKE SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES ON deptest FROM regression_user;
DROP USER regression_user;
REVOKE TRIGGER ON deptest FROM regression_user;
DROP USER regression_user;
REVOKE ALL ON deptest FROM regression_user2;
DROP USER regression_user2;
ALTER TABLE deptest OWNER TO regression_user3;
DROP USER regression_user3;
DROP TABLE deptest;
DROP USER regression_user3;
CREATE USER regression_user0;
CREATE USER regression_user1;
CREATE USER regression_user2;
SET SESSION AUTHORIZATION regression_user0;
DROP OWNED BY regression_user1;
DROP OWNED BY regression_user0, regression_user2;
REASSIGN OWNED BY regression_user0 TO regression_user1;
REASSIGN OWNED BY regression_user1 TO regression_user0;
DROP OWNED BY regression_user0;
CREATE TABLE deptest1 (f1 int unique);
GRANT ALL ON deptest1 TO regression_user1 WITH GRANT OPTION;
SET SESSION AUTHORIZATION regression_user1;
CREATE TABLE deptest (a serial primary key, b text);
GRANT ALL ON deptest1 TO regression_user2;
RESET SESSION AUTHORIZATION;
SELECT n.nspname as "Schema",  c.relname as "Name",  CASE c.relkind WHEN 'r' THEN 'table' WHEN 'v' THEN 'view' WHEN 'm' THEN 'materialized view' WHEN 'S' THEN 'sequence' WHEN 'f' THEN 'foreign table' END as "Type",  pg_catalog.array_to_string(c.relacl, E'\n') AS "Access privileges",  pg_catalog.array_to_string(ARRAY(  SELECT attname || E':\n ' || pg_catalog.array_to_string(attacl, E'\n ')  FROM pg_catalog.pg_attribute a  WHERE attrelid = c.oid AND NOT attisdropped AND attacl IS NOT NULL  ), E'\n') AS "Column privileges",  pg_catalog.array_to_string(ARRAY(  SELECT polname  || CASE WHEN polcmd != '*' THEN  E' (' || polcmd || E'):'  ELSE E':'  END  || CASE WHEN polqual IS NOT NULL THEN  E'\n (u): ' || pg_catalog.pg_get_expr(polqual, polrelid)  ELSE E''  END  || CASE WHEN polwithcheck IS NOT NULL THEN  E'\n (c): ' || pg_catalog.pg_get_expr(polwithcheck, polrelid)  ELSE E''  END || CASE WHEN polroles <> '{0}' THEN  E'\n to: ' || pg_catalog.array_to_string(  ARRAY(  SELECT rolname  FROM pg_catalog.pg_roles  WHERE oid = ANY (polroles)  ORDER BY 1  ), E', ')  ELSE E''  END  FROM pg_catalog.pg_policy pol  WHERE polrelid = c.oid), E'\n')  AS "Policies"  FROM pg_catalog.pg_class c  LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace  WHERE c.relkind IN ('r', 'v', 'm', 'S', 'f')  AND c.relname ~ '^(deptest1)$'  AND n.nspname !~ '^pg_' AND pg_catalog.pg_table_is_visible(c.oid)  ORDER BY 1, 2;
DROP OWNED BY regression_user1;
SELECT n.nspname as "Schema",  c.relname as "Name",  CASE c.relkind WHEN 'r' THEN 'table' WHEN 'v' THEN 'view' WHEN 'm' THEN 'materialized view' WHEN 'S' THEN 'sequence' WHEN 'f' THEN 'foreign table' END as "Type",  pg_catalog.array_to_string(c.relacl, E'\n') AS "Access privileges",  pg_catalog.array_to_string(ARRAY(  SELECT attname || E':\n ' || pg_catalog.array_to_string(attacl, E'\n ')  FROM pg_catalog.pg_attribute a  WHERE attrelid = c.oid AND NOT attisdropped AND attacl IS NOT NULL  ), E'\n') AS "Column privileges",  pg_catalog.array_to_string(ARRAY(  SELECT polname  || CASE WHEN polcmd != '*' THEN  E' (' || polcmd || E'):'  ELSE E':'  END  || CASE WHEN polqual IS NOT NULL THEN  E'\n (u): ' || pg_catalog.pg_get_expr(polqual, polrelid)  ELSE E''  END  || CASE WHEN polwithcheck IS NOT NULL THEN  E'\n (c): ' || pg_catalog.pg_get_expr(polwithcheck, polrelid)  ELSE E''  END || CASE WHEN polroles <> '{0}' THEN  E'\n to: ' || pg_catalog.array_to_string(  ARRAY(  SELECT rolname  FROM pg_catalog.pg_roles  WHERE oid = ANY (polroles)  ORDER BY 1  ), E', ')  ELSE E''  END  FROM pg_catalog.pg_policy pol  WHERE polrelid = c.oid), E'\n')  AS "Policies"  FROM pg_catalog.pg_class c  LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace  WHERE c.relkind IN ('r', 'v', 'm', 'S', 'f')  AND c.relname ~ '^(deptest1)$'  AND n.nspname !~ '^pg_' AND pg_catalog.pg_table_is_visible(c.oid)  ORDER BY 1, 2;
SELECT c.oid,  n.nspname,  c.relname  FROM pg_catalog.pg_class c  LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace  WHERE c.relname ~ '^(deptest)$'  AND pg_catalog.pg_table_is_visible(c.oid)  ORDER BY 2, 3;
GRANT ALL ON deptest1 TO regression_user1;
GRANT CREATE ON DATABASE regression TO regression_user1;
SET SESSION AUTHORIZATION regression_user1;
CREATE SCHEMA deptest;
CREATE TABLE deptest (a serial primary key, b text);
ALTER DEFAULT PRIVILEGES FOR ROLE regression_user1 IN SCHEMA deptest  GRANT ALL ON TABLES TO regression_user2;
CREATE FUNCTION deptest_func() RETURNS void LANGUAGE plpgsql  AS $$ BEGIN END; $$;
CREATE TYPE deptest_enum AS ENUM ('red');
CREATE TYPE deptest_range AS RANGE (SUBTYPE = int4);
CREATE TABLE deptest2 (f1 int);
CREATE SEQUENCE ss1;
ALTER TABLE deptest2 ALTER f1 SET DEFAULT nextval('ss1');
ALTER SEQUENCE ss1 OWNED BY deptest2.f1;
CREATE TYPE deptest_t AS (a int);
SELECT typowner = relowner  FROM pg_type JOIN pg_class c ON typrelid = c.oid WHERE typname = 'deptest_t';
RESET SESSION AUTHORIZATION;
REASSIGN OWNED BY regression_user1 TO regression_user2;
SELECT n.nspname as "Schema",  c.relname as "Name",  CASE c.relkind WHEN 'r' THEN 'table' WHEN 'v' THEN 'view' WHEN 'm' THEN 'materialized view' WHEN 'i' THEN 'index' WHEN 'S' THEN 'sequence' WHEN 's' THEN 'special' WHEN 'f' THEN 'foreign table' END as "Type", pg_catalog.pg_get_userbyid(c.relowner) as "Owner"  FROM pg_catalog.pg_class c  LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace  WHERE c.relkind IN ('r','s','')  AND n.nspname !~ '^pg_toast'  AND c.relname ~ '^(deptest)$'  AND pg_catalog.pg_table_is_visible(c.oid)  ORDER BY 1,2;
SELECT typowner = relowner  FROM pg_type JOIN pg_class c ON typrelid = c.oid WHERE typname = 'deptest_t';
DROP USER regression_user1;
DROP OWNED BY regression_user1;
DROP USER regression_user1;
DROP USER regression_user2;
DROP OWNED BY regression_user2, regression_user0;
DROP USER regression_user2;
DROP USER regression_user0;
