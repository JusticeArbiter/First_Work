LOG:  statement: select message from postgres_log where query is null;
 statement: CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified');
 statement: INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
 statement: CREATE VIEW ro_view1 AS SELECT DISTINCT a, b FROM base_tbl;
 statement: CREATE VIEW ro_view2 AS SELECT a, b FROM base_tbl GROUP BY a, b;
 statement: CREATE VIEW ro_view3 AS SELECT 1 FROM base_tbl HAVING max(a) > 0;
 statement: CREATE VIEW ro_view4 AS SELECT count(*) FROM base_tbl;
 statement: CREATE VIEW ro_view5 AS SELECT a, rank() OVER() FROM base_tbl;
 statement: CREATE VIEW ro_view6 AS SELECT a, b FROM base_tbl UNION SELECT -a, b FROM base_tbl;
 statement: CREATE VIEW ro_view7 AS WITH t AS (SELECT a, b FROM base_tbl) SELECT * FROM t;
 statement: CREATE VIEW ro_view8 AS SELECT a, b FROM base_tbl ORDER BY a OFFSET 1;
 statement: CREATE VIEW ro_view9 AS SELECT a, b FROM base_tbl ORDER BY a LIMIT 1;
 statement: CREATE VIEW ro_view10 AS SELECT 1 AS a;
 statement: CREATE VIEW ro_view11 AS SELECT b1.a, b2.b FROM base_tbl b1, base_tbl b2;
 statement: CREATE VIEW ro_view12 AS SELECT * FROM generate_series(1, 10) AS g(a);
 statement: CREATE VIEW ro_view13 AS SELECT a, b FROM (SELECT * FROM base_tbl) AS t;
 statement: CREATE VIEW rw_view14 AS SELECT ctid, a, b FROM base_tbl;
 statement: CREATE VIEW rw_view15 AS SELECT a, upper(b) FROM base_tbl;
 statement: CREATE VIEW rw_view16 AS SELECT a, b, a AS aa FROM base_tbl;
 statement: CREATE VIEW ro_view17 AS SELECT * FROM ro_view1;
 statement: CREATE VIEW ro_view18 AS SELECT * FROM (VALUES(1)) AS tmp(a);
 statement: CREATE SEQUENCE seq;
 statement: CREATE VIEW ro_view19 AS SELECT * FROM seq;
 statement: CREATE VIEW ro_view20 AS SELECT a, b, generate_series(1, a) g FROM base_tbl;
 statement: SELECT table_name, is_insertable_into                                                                                                                                                                                                                      +
   FROM information_schema.tables                                                                                                                                                                                                                                      +
  WHERE table_name LIKE E'r_\\_view%'                                                                                                                                                                                                                                  +
  ORDER BY table_name;
 statement: SELECT table_name, is_updatable, is_insertable_into                                                                                                                                                                                                        +
   FROM information_schema.views                                                                                                                                                                                                                                       +
  WHERE table_name LIKE E'r_\\_view%'                                                                                                                                                                                                                                  +
  ORDER BY table_name;
 statement: SELECT table_name, column_name, is_updatable                                                                                                                                                                                                               +
   FROM information_schema.columns                                                                                                                                                                                                                                     +
  WHERE table_name LIKE E'r_\\_view%'                                                                                                                                                                                                                                  +
  ORDER BY table_name, ordinal_position;
 statement: DELETE FROM ro_view1;
 statement: DELETE FROM ro_view2;
 statement: DELETE FROM ro_view3;
 statement: DELETE FROM ro_view4;
 statement: DELETE FROM ro_view5;
 statement: DELETE FROM ro_view6;
 statement: UPDATE ro_view7 SET a=a+1;
 statement: UPDATE ro_view8 SET a=a+1;
 statement: UPDATE ro_view9 SET a=a+1;
 statement: UPDATE ro_view10 SET a=a+1;
 statement: UPDATE ro_view11 SET a=a+1;
 statement: UPDATE ro_view12 SET a=a+1;
 statement: INSERT INTO ro_view13 VALUES (3, 'Row 3');
 statement: INSERT INTO rw_view14 VALUES (null, 3, 'Row 3');
 statement: INSERT INTO rw_view14 (a, b) VALUES (3, 'Row 3');
 statement: UPDATE rw_view14 SET ctid=null WHERE a=3;
 statement: UPDATE rw_view14 SET b='ROW 3' WHERE a=3;
 statement: SELECT * FROM base_tbl;
 statement: DELETE FROM rw_view14 WHERE a=3;
 statement: INSERT INTO rw_view15 VALUES (3, 'ROW 3');
 statement: INSERT INTO rw_view15 (a) VALUES (3);
 statement: INSERT INTO rw_view15 (a) VALUES (3) ON CONFLICT DO NOTHING;
 statement: SELECT * FROM rw_view15;
 statement: INSERT INTO rw_view15 (a) VALUES (3) ON CONFLICT (a) DO NOTHING;
 statement: SELECT * FROM rw_view15;
 statement: INSERT INTO rw_view15 (a) VALUES (3) ON CONFLICT (a) DO UPDATE set a = excluded.a;
 statement: SELECT * FROM rw_view15;
 statement: INSERT INTO rw_view15 (a) VALUES (3) ON CONFLICT (a) DO UPDATE set upper = 'blarg';
 statement: SELECT * FROM rw_view15;
 statement: SELECT * FROM rw_view15;
 statement: ALTER VIEW rw_view15 ALTER COLUMN upper SET DEFAULT 'NOT SET';
 statement: INSERT INTO rw_view15 (a) VALUES (4);
 statement: UPDATE rw_view15 SET upper='ROW 3' WHERE a=3;
 statement: UPDATE rw_view15 SET upper=DEFAULT WHERE a=3;
 statement: UPDATE rw_view15 SET a=4 WHERE a=3;
 statement: SELECT * FROM base_tbl;
 statement: DELETE FROM rw_view15 WHERE a=4;
 statement: INSERT INTO rw_view16 VALUES (3, 'Row 3', 3);
 statement: INSERT INTO rw_view16 (a, b) VALUES (3, 'Row 3');
 statement: UPDATE rw_view16 SET a=3, aa=-3 WHERE a=3;
 statement: UPDATE rw_view16 SET aa=-3 WHERE a=3;
 statement: SELECT * FROM base_tbl;
 statement: DELETE FROM rw_view16 WHERE a=-3;
 statement: INSERT INTO ro_view17 VALUES (3, 'ROW 3');
 statement: DELETE FROM ro_view18;
 statement: UPDATE ro_view19 SET max_value=1000;
 statement: UPDATE ro_view20 SET b=upper(b);
 statement: DROP TABLE base_tbl CASCADE;
 statement: DROP VIEW ro_view10, ro_view12, ro_view18;
 statement: DROP SEQUENCE seq CASCADE;
 statement: CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified');
 statement: INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
 statement: CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a>0;
 statement: SELECT table_name, is_insertable_into                                                                                                                                                                                                                      +
   FROM information_schema.tables                                                                                                                                                                                                                                      +
  WHERE table_name = 'rw_view1';
 statement: SELECT table_name, is_updatable, is_insertable_into                                                                                                                                                                                                        +
   FROM information_schema.views                                                                                                                                                                                                                                       +
  WHERE table_name = 'rw_view1';
 statement: SELECT table_name, column_name, is_updatable                                                                                                                                                                                                               +
   FROM information_schema.columns                                                                                                                                                                                                                                     +
  WHERE table_name = 'rw_view1'                                                                                                                                                                                                                                        +
  ORDER BY ordinal_position;
 statement: INSERT INTO rw_view1 VALUES (3, 'Row 3');
 statement: INSERT INTO rw_view1 (a) VALUES (4);
 statement: UPDATE rw_view1 SET a=5 WHERE a=4;
 statement: DELETE FROM rw_view1 WHERE b='Row 2';
 statement: SELECT * FROM base_tbl;
 statement: EXPLAIN (costs off) UPDATE rw_view1 SET a=6 WHERE a=5;
 statement: EXPLAIN (costs off) DELETE FROM rw_view1 WHERE a=5;
 statement: DROP TABLE base_tbl CASCADE;
 statement: CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified');
 statement: INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
 statement: CREATE VIEW rw_view1 AS SELECT b AS bb, a AS aa FROM base_tbl WHERE a>0;
 statement: CREATE VIEW rw_view2 AS SELECT aa AS aaa, bb AS bbb FROM rw_view1 WHERE aa<10;
 statement: SELECT table_name, is_insertable_into                                                                                                                                                                                                                      +
   FROM information_schema.tables                                                                                                                                                                                                                                      +
  WHERE table_name = 'rw_view2';
 statement: SELECT table_name, is_updatable, is_insertable_into                                                                                                                                                                                                        +
   FROM information_schema.views                                                                                                                                                                                                                                       +
  WHERE table_name = 'rw_view2';
 statement: SELECT table_name, column_name, is_updatable                                                                                                                                                                                                               +
   FROM information_schema.columns                                                                                                                                                                                                                                     +
  WHERE table_name = 'rw_view2'                                                                                                                                                                                                                                        +
  ORDER BY ordinal_position;
 statement: INSERT INTO rw_view2 VALUES (3, 'Row 3');
 statement: INSERT INTO rw_view2 (aaa) VALUES (4);
 statement: SELECT * FROM rw_view2;
 statement: UPDATE rw_view2 SET bbb='Row 4' WHERE aaa=4;
 statement: DELETE FROM rw_view2 WHERE aaa=2;
 statement: SELECT * FROM rw_view2;
 statement: EXPLAIN (costs off) UPDATE rw_view2 SET aaa=5 WHERE aaa=4;
 statement: EXPLAIN (costs off) DELETE FROM rw_view2 WHERE aaa=4;
 statement: DROP TABLE base_tbl CASCADE;
 statement: CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified');
 statement: INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
 statement: CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a>0 OFFSET 0;
 statement: CREATE VIEW rw_view2 AS SELECT * FROM rw_view1 WHERE a<10;
 statement: SELECT table_name, is_insertable_into                                                                                                                                                                                                                      +
   FROM information_schema.tables                                                                                                                                                                                                                                      +
  WHERE table_name LIKE 'rw_view%'                                                                                                                                                                                                                                     +
  ORDER BY table_name;
 statement: SELECT table_name, is_updatable, is_insertable_into                                                                                                                                                                                                        +
   FROM information_schema.views                                                                                                                                                                                                                                       +
  WHERE table_name LIKE 'rw_view%'                                                                                                                                                                                                                                     +
  ORDER BY table_name;
 statement: SELECT table_name, column_name, is_updatable                                                                                                                                                                                                               +
   FROM information_schema.columns                                                                                                                                                                                                                                     +
  WHERE table_name LIKE 'rw_view%'                                                                                                                                                                                                                                     +
  ORDER BY table_name, ordinal_position;
 statement: CREATE RULE rw_view1_ins_rule AS ON INSERT TO rw_view1                                                                                                                                                                                                     +
   DO INSTEAD INSERT INTO base_tbl VALUES (NEW.a, NEW.b) RETURNING *;
 statement: SELECT table_name, is_insertable_into                                                                                                                                                                                                                      +
   FROM information_schema.tables                                                                                                                                                                                                                                      +
  WHERE table_name LIKE 'rw_view%'                                                                                                                                                                                                                                     +
  ORDER BY table_name;
 statement: SELECT table_name, is_updatable, is_insertable_into                                                                                                                                                                                                        +
   FROM information_schema.views                                                                                                                                                                                                                                       +
  WHERE table_name LIKE 'rw_view%'                                                                                                                                                                                                                                     +
  ORDER BY table_name;
 statement: SELECT table_name, column_name, is_updatable                                                                                                                                                                                                               +
   FROM information_schema.columns                                                                                                                                                                                                                                     +
  WHERE table_name LIKE 'rw_view%'                                                                                                                                                                                                                                     +
  ORDER BY table_name, ordinal_position;
 statement: CREATE RULE rw_view1_upd_rule AS ON UPDATE TO rw_view1                                                                                                                                                                                                     +
   DO INSTEAD UPDATE base_tbl SET b=NEW.b WHERE a=OLD.a RETURNING NEW.*;
 statement: SELECT table_name, is_insertable_into                                                                                                                                                                                                                      +
   FROM information_schema.tables                                                                                                                                                                                                                                      +
  WHERE table_name LIKE 'rw_view%'                                                                                                                                                                                                                                     +
  ORDER BY table_name;
 statement: SELECT table_name, is_updatable, is_insertable_into                                                                                                                                                                                                        +
   FROM information_schema.views                                                                                                                                                                                                                                       +
  WHERE table_name LIKE 'rw_view%'                                                                                                                                                                                                                                     +
  ORDER BY table_name;
 statement: SELECT table_name, column_name, is_updatable                                                                                                                                                                                                               +
   FROM information_schema.columns                                                                                                                                                                                                                                     +
  WHERE table_name LIKE 'rw_view%'                                                                                                                                                                                                                                     +
  ORDER BY table_name, ordinal_position;
 statement: CREATE RULE rw_view1_del_rule AS ON DELETE TO rw_view1                                                                                                                                                                                                     +
   DO INSTEAD DELETE FROM base_tbl WHERE a=OLD.a RETURNING OLD.*;
 statement: SELECT table_name, is_insertable_into                                                                                                                                                                                                                      +
   FROM information_schema.tables                                                                                                                                                                                                                                      +
  WHERE table_name LIKE 'rw_view%'                                                                                                                                                                                                                                     +
  ORDER BY table_name;
 statement: SELECT table_name, is_updatable, is_insertable_into                                                                                                                                                                                                        +
   FROM information_schema.views                                                                                                                                                                                                                                       +
  WHERE table_name LIKE 'rw_view%'                                                                                                                                                                                                                                     +
  ORDER BY table_name;
 statement: SELECT table_name, column_name, is_updatable                                                                                                                                                                                                               +
   FROM information_schema.columns                                                                                                                                                                                                                                     +
  WHERE table_name LIKE 'rw_view%'                                                                                                                                                                                                                                     +
  ORDER BY table_name, ordinal_position;
 statement: INSERT INTO rw_view2 VALUES (3, 'Row 3') RETURNING *;
 statement: UPDATE rw_view2 SET b='Row three' WHERE a=3 RETURNING *;
 statement: SELECT * FROM rw_view2;
 statement: DELETE FROM rw_view2 WHERE a=3 RETURNING *;
 statement: SELECT * FROM rw_view2;
 statement: EXPLAIN (costs off) UPDATE rw_view2 SET a=3 WHERE a=2;
 statement: EXPLAIN (costs off) DELETE FROM rw_view2 WHERE a=2;
 statement: DROP TABLE base_tbl CASCADE;
 statement: CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified');
 statement: INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
 statement: CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a>0 OFFSET 0;
 statement: CREATE VIEW rw_view2 AS SELECT * FROM rw_view1 WHERE a<10;
 statement: SELECT table_name, is_insertable_into                                                                                                                                                                                                                      +
   FROM information_schema.tables                                                                                                                                                                                                                                      +
  WHERE table_name LIKE 'rw_view%'                                                                                                                                                                                                                                     +
  ORDER BY table_name;
 statement: SELECT table_name, is_updatable, is_insertable_into,                                                                                                                                                                                                       +
        is_trigger_updatable, is_trigger_deletable,                                                                                                                                                                                                                    +
        is_trigger_insertable_into                                                                                                                                                                                                                                     +
   FROM information_schema.views                                                                                                                                                                                                                                       +
  WHERE table_name LIKE 'rw_view%'                                                                                                                                                                                                                                     +
  ORDER BY table_name;
 statement: SELECT table_name, column_name, is_updatable                                                                                                                                                                                                               +
   FROM information_schema.columns                                                                                                                                                                                                                                     +
  WHERE table_name LIKE 'rw_view%'                                                                                                                                                                                                                                     +
  ORDER BY table_name, ordinal_position;
 statement: CREATE FUNCTION rw_view1_trig_fn()                                                                                                                                                                                                                         +
 RETURNS trigger AS                                                                                                                                                                                                                                                    +
 $$                                                                                                                                                                                                                                                                    +
 BEGIN                                                                                                                                                                                                                                                                 +
   IF TG_OP = 'INSERT' THEN                                                                                                                                                                                                                                            +
     INSERT INTO base_tbl VALUES (NEW.a, NEW.b);                                                                                                                                                                                                                       +
     RETURN NEW;                                                                                                                                                                                                                                                       +
   ELSIF TG_OP = 'UPDATE' THEN                                                                                                                                                                                                                                         +
     UPDATE base_tbl SET b=NEW.b WHERE a=OLD.a;                                                                                                                                                                                                                        +
     RETURN NEW;                                                                                                                                                                                                                                                       +
   ELSIF TG_OP = 'DELETE' THEN                                                                                                                                                                                                                                         +
     DELETE FROM base_tbl WHERE a=OLD.a;                                                                                                                                                                                                                               +
     RETURN OLD;                                                                                                                                                                                                                                                       +
   END IF;                                                                                                                                                                                                                                                             +
 END;                                                                                                                                                                                                                                                                  +
 $$                                                                                                                                                                                                                                                                    +
 LANGUAGE plpgsql;
 statement: CREATE TRIGGER rw_view1_ins_trig INSTEAD OF INSERT ON rw_view1                                                                                                                                                                                             +
   FOR EACH ROW EXECUTE PROCEDURE rw_view1_trig_fn();
 statement: SELECT table_name, is_insertable_into                                                                                                                                                                                                                      +
   FROM information_schema.tables                                                                                                                                                                                                                                      +
  WHERE table_name LIKE 'rw_view%'                                                                                                                                                                                                                                     +
  ORDER BY table_name;
 statement: SELECT table_name, is_updatable, is_insertable_into,                                                                                                                                                                                                       +
        is_trigger_updatable, is_trigger_deletable,                                                                                                                                                                                                                    +
        is_trigger_insertable_into                                                                                                                                                                                                                                     +
   FROM information_schema.views                                                                                                                                                                                                                                       +
  WHERE table_name LIKE 'rw_view%'                                                                                                                                                                                                                                     +
  ORDER BY table_name;
 statement: SELECT table_name, column_name, is_updatable                                                                                                                                                                                                               +
   FROM information_schema.columns                                                                                                                                                                                                                                     +
  WHERE table_name LIKE 'rw_view%'                                                                                                                                                                                                                                     +
  ORDER BY table_name, ordinal_position;
 statement: CREATE TRIGGER rw_view1_upd_trig INSTEAD OF UPDATE ON rw_view1                                                                                                                                                                                             +
   FOR EACH ROW EXECUTE PROCEDURE rw_view1_trig_fn();
 statement: SELECT table_name, is_insertable_into                                                                                                                                                                                                                      +
   FROM information_schema.tables                                                                                                                                                                                                                                      +
  WHERE table_name LIKE 'rw_view%'                                                                                                                                                                                                                                     +
  ORDER BY table_name;
 statement: SELECT table_name, is_updatable, is_insertable_into,                                                                                                                                                                                                       +
        is_trigger_updatable, is_trigger_deletable,                                                                                                                                                                                                                    +
        is_trigger_insertable_into                                                                                                                                                                                                                                     +
   FROM information_schema.views                                                                                                                                                                                                                                       +
  WHERE table_name LIKE 'rw_view%'                                                                                                                                                                                                                                     +
  ORDER BY table_name;
 statement: SELECT table_name, column_name, is_updatable                                                                                                                                                                                                               +
   FROM information_schema.columns                                                                                                                                                                                                                                     +
  WHERE table_name LIKE 'rw_view%'                                                                                                                                                                                                                                     +
  ORDER BY table_name, ordinal_position;
 statement: CREATE TRIGGER rw_view1_del_trig INSTEAD OF DELETE ON rw_view1                                                                                                                                                                                             +
   FOR EACH ROW EXECUTE PROCEDURE rw_view1_trig_fn();
 statement: SELECT table_name, is_insertable_into                                                                                                                                                                                                                      +
   FROM information_schema.tables                                                                                                                                                                                                                                      +
  WHERE table_name LIKE 'rw_view%'                                                                                                                                                                                                                                     +
  ORDER BY table_name;
 statement: SELECT table_name, is_updatable, is_insertable_into,                                                                                                                                                                                                       +
        is_trigger_updatable, is_trigger_deletable,                                                                                                                                                                                                                    +
        is_trigger_insertable_into                                                                                                                                                                                                                                     +
   FROM information_schema.views                                                                                                                                                                                                                                       +
  WHERE table_name LIKE 'rw_view%'                                                                                                                                                                                                                                     +
  ORDER BY table_name;
 statement: SELECT table_name, column_name, is_updatable                                                                                                                                                                                                               +
   FROM information_schema.columns                                                                                                                                                                                                                                     +
  WHERE table_name LIKE 'rw_view%'                                                                                                                                                                                                                                     +
  ORDER BY table_name, ordinal_position;
 statement: INSERT INTO rw_view2 VALUES (3, 'Row 3') RETURNING *;
 statement: UPDATE rw_view2 SET b='Row three' WHERE a=3 RETURNING *;
 statement: SELECT * FROM rw_view2;
 statement: DELETE FROM rw_view2 WHERE a=3 RETURNING *;
 statement: SELECT * FROM rw_view2;
 statement: EXPLAIN (costs off) UPDATE rw_view2 SET a=3 WHERE a=2;
 statement: EXPLAIN (costs off) DELETE FROM rw_view2 WHERE a=2;
 statement: DROP TABLE base_tbl CASCADE;
 statement: DROP FUNCTION rw_view1_trig_fn();
 statement: CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified');
 statement: INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
 statement: CREATE VIEW rw_view1 AS SELECT b AS bb, a AS aa FROM base_tbl;
 statement: CREATE FUNCTION rw_view1_aa(x rw_view1)                                                                                                                                                                                                                    +
   RETURNS int AS $$ SELECT x.aa $$ LANGUAGE sql;
 statement: UPDATE rw_view1 v SET bb='Updated row 2' WHERE rw_view1_aa(v)=2                                                                                                                                                                                            +
   RETURNING rw_view1_aa(v), v.bb;
 statement: SELECT * FROM base_tbl;
 statement: EXPLAIN (costs off)                                                                                                                                                                                                                                        +
 UPDATE rw_view1 v SET bb='Updated row 2' WHERE rw_view1_aa(v)=2                                                                                                                                                                                                       +
   RETURNING rw_view1_aa(v), v.bb;
 statement: DROP TABLE base_tbl CASCADE;
 statement: CREATE USER view_user1;
 statement: CREATE USER view_user2;
 statement: SET SESSION AUTHORIZATION view_user1;
 statement: CREATE TABLE base_tbl(a int, b text, c float);
 statement: INSERT INTO base_tbl VALUES (1, 'Row 1', 1.0);
 statement: CREATE VIEW rw_view1 AS SELECT b AS bb, c AS cc, a AS aa FROM base_tbl;
 statement: INSERT INTO rw_view1 VALUES ('Row 2', 2.0, 2);
 statement: GRANT SELECT ON base_tbl TO view_user2;
 statement: GRANT SELECT ON rw_view1 TO view_user2;
 statement: GRANT UPDATE (a,c) ON base_tbl TO view_user2;
 statement: GRANT UPDATE (bb,cc) ON rw_view1 TO view_user2;
 statement: RESET SESSION AUTHORIZATION;
 statement: SET SESSION AUTHORIZATION view_user2;
 statement: CREATE VIEW rw_view2 AS SELECT b AS bb, c AS cc, a AS aa FROM base_tbl;
 statement: SELECT * FROM base_tbl;
 statement: SELECT * FROM rw_view1;
 statement: SELECT * FROM rw_view2;
 statement: INSERT INTO base_tbl VALUES (3, 'Row 3', 3.0);
 statement: INSERT INTO rw_view1 VALUES ('Row 3', 3.0, 3);
 statement: INSERT INTO rw_view2 VALUES ('Row 3', 3.0, 3);
 statement: UPDATE base_tbl SET a=a, c=c;
 statement: UPDATE base_tbl SET b=b;
 statement: UPDATE rw_view1 SET bb=bb, cc=cc;
 statement: UPDATE rw_view1 SET aa=aa;
 statement: UPDATE rw_view2 SET aa=aa, cc=cc;
 statement: UPDATE rw_view2 SET bb=bb;
 statement: DELETE FROM base_tbl;
 statement: DELETE FROM rw_view1;
 statement: DELETE FROM rw_view2;
 statement: RESET SESSION AUTHORIZATION;
 statement: SET SESSION AUTHORIZATION view_user1;
 statement: GRANT INSERT, DELETE ON base_tbl TO view_user2;
 statement: RESET SESSION AUTHORIZATION;
 statement: SET SESSION AUTHORIZATION view_user2;
 statement: INSERT INTO base_tbl VALUES (3, 'Row 3', 3.0);
 statement: INSERT INTO rw_view1 VALUES ('Row 4', 4.0, 4);
 statement: INSERT INTO rw_view2 VALUES ('Row 4', 4.0, 4);
 statement: DELETE FROM base_tbl WHERE a=1;
 statement: DELETE FROM rw_view1 WHERE aa=2;
 statement: DELETE FROM rw_view2 WHERE aa=2;
 statement: SELECT * FROM base_tbl;
 statement: RESET SESSION AUTHORIZATION;
 statement: SET SESSION AUTHORIZATION view_user1;
 statement: REVOKE INSERT, DELETE ON base_tbl FROM view_user2;
 statement: GRANT INSERT, DELETE ON rw_view1 TO view_user2;
 statement: RESET SESSION AUTHORIZATION;
 statement: SET SESSION AUTHORIZATION view_user2;
 statement: INSERT INTO base_tbl VALUES (5, 'Row 5', 5.0);
 statement: INSERT INTO rw_view1 VALUES ('Row 5', 5.0, 5);
 statement: INSERT INTO rw_view2 VALUES ('Row 6', 6.0, 6);
 statement: DELETE FROM base_tbl WHERE a=3;
 statement: DELETE FROM rw_view1 WHERE aa=3;
 statement: DELETE FROM rw_view2 WHERE aa=4;
 statement: SELECT * FROM base_tbl;
 statement: RESET SESSION AUTHORIZATION;
 statement: DROP TABLE base_tbl CASCADE;
 statement: DROP USER view_user1;
 statement: DROP USER view_user2;
 statement: CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified', c serial);
 statement: INSERT INTO base_tbl VALUES (1, 'Row 1');
 statement: INSERT INTO base_tbl VALUES (2, 'Row 2');
 statement: INSERT INTO base_tbl VALUES (3);
 statement: CREATE VIEW rw_view1 AS SELECT a AS aa, b AS bb FROM base_tbl;
 statement: ALTER VIEW rw_view1 ALTER COLUMN bb SET DEFAULT 'View default';
 statement: INSERT INTO rw_view1 VALUES (4, 'Row 4');
 statement: INSERT INTO rw_view1 (aa) VALUES (5);
 statement: SELECT * FROM base_tbl;
 statement: DROP TABLE base_tbl CASCADE;
 statement: CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified');
 statement: INSERT INTO base_tbl VALUES (1, 'Row 1');
 statement: INSERT INTO base_tbl VALUES (2, 'Row 2');
 statement: CREATE FUNCTION rw_view1_trig_fn()                                                                                                                                                                                                                         +
 RETURNS trigger AS                                                                                                                                                                                                                                                    +
 $$                                                                                                                                                                                                                                                                    +
 BEGIN                                                                                                                                                                                                                                                                 +
   IF TG_OP = 'INSERT' THEN                                                                                                                                                                                                                                            +
     UPDATE base_tbl SET b=NEW.b WHERE a=1;                                                                                                                                                                                                                            +
     RETURN NULL;                                                                                                                                                                                                                                                      +
   END IF;                                                                                                                                                                                                                                                             +
   RETURN NULL;                                                                                                                                                                                                                                                        +
 END;                                                                                                                                                                                                                                                                  +
 $$                                                                                                                                                                                                                                                                    +
 LANGUAGE plpgsql;
 statement: CREATE TRIGGER rw_view1_ins_trig AFTER INSERT ON base_tbl                                                                                                                                                                                                  +
   FOR EACH ROW EXECUTE PROCEDURE rw_view1_trig_fn();
 statement: CREATE VIEW rw_view1 AS SELECT a AS aa, b AS bb FROM base_tbl;
 statement: INSERT INTO rw_view1 VALUES (3, 'Row 3');
 statement: select * from base_tbl;
 statement: DROP VIEW rw_view1;
 statement: DROP TRIGGER rw_view1_ins_trig on base_tbl;
 statement: DROP FUNCTION rw_view1_trig_fn();
 statement: DROP TABLE base_tbl;
 statement: CREATE TABLE base_tbl (a int, b int);
 statement: INSERT INTO base_tbl VALUES (1,2), (4,5), (3,-3);
 statement: CREATE VIEW rw_view1 AS SELECT * FROM base_tbl ORDER BY a+b;
 statement: SELECT * FROM rw_view1;
 statement: INSERT INTO rw_view1 VALUES (7,-8);
 statement: SELECT * FROM rw_view1;
 statement: EXPLAIN (verbose, costs off) UPDATE rw_view1 SET b = b + 1 RETURNING *;
 statement: UPDATE rw_view1 SET b = b + 1 RETURNING *;
 statement: SELECT * FROM rw_view1;
 statement: DROP TABLE base_tbl CASCADE;
 statement: CREATE TABLE base_tbl (a int, arr int[]);
 statement: INSERT INTO base_tbl VALUES (1,ARRAY[2]), (3,ARRAY[4]);
 statement: CREATE VIEW rw_view1 AS SELECT * FROM base_tbl;
 statement: UPDATE rw_view1 SET arr[1] = 42, arr[2] = 77 WHERE a = 3;
 statement: SELECT * FROM rw_view1;
 statement: DROP TABLE base_tbl CASCADE;
 statement: CREATE TABLE base_tbl(a float);
 statement: INSERT INTO base_tbl SELECT i/10.0 FROM generate_series(1,10) g(i);
 statement: CREATE VIEW rw_view1 AS                                                                                                                                                                                                                                    +
   SELECT ctid, sin(a) s, a, cos(a) c                                                                                                                                                                                                                                  +
   FROM base_tbl                                                                                                                                                                                                                                                       +
   WHERE a != 0                                                                                                                                                                                                                                                        +
   ORDER BY abs(a);
 statement: INSERT INTO rw_view1 VALUES (null, null, 1.1, null);
 statement: INSERT INTO rw_view1 (s, c, a) VALUES (null, null, 1.1);
 statement: INSERT INTO rw_view1 (a) VALUES (1.1) RETURNING a, s, c;
 statement: UPDATE rw_view1 SET s = s WHERE a = 1.1;
 statement: UPDATE rw_view1 SET a = 1.05 WHERE a = 1.1 RETURNING s;
 statement: DELETE FROM rw_view1 WHERE a = 1.05;
 statement: CREATE VIEW rw_view2 AS                                                                                                                                                                                                                                    +
   SELECT s, c, s/c t, a base_a, ctid                                                                                                                                                                                                                                  +
   FROM rw_view1;
 statement: INSERT INTO rw_view2 VALUES (null, null, null, 1.1, null);
 statement: INSERT INTO rw_view2(s, c, base_a) VALUES (null, null, 1.1);
 statement: INSERT INTO rw_view2(base_a) VALUES (1.1) RETURNING t;
 statement: UPDATE rw_view2 SET s = s WHERE base_a = 1.1;
 statement: UPDATE rw_view2 SET t = t WHERE base_a = 1.1;
 statement: UPDATE rw_view2 SET base_a = 1.05 WHERE base_a = 1.1;
 statement: DELETE FROM rw_view2 WHERE base_a = 1.05 RETURNING base_a, s, c, t;
 statement: CREATE VIEW rw_view3 AS                                                                                                                                                                                                                                    +
   SELECT s, c, s/c t, ctid                                                                                                                                                                                                                                            +
   FROM rw_view1;
 statement: INSERT INTO rw_view3 VALUES (null, null, null, null);
 statement: INSERT INTO rw_view3(s) VALUES (null);
 statement: UPDATE rw_view3 SET s = s;
 statement: DELETE FROM rw_view3 WHERE s = sin(0.1);
 statement: SELECT * FROM base_tbl ORDER BY a;
 statement: SELECT table_name, is_insertable_into                                                                                                                                                                                                                      +
   FROM information_schema.tables                                                                                                                                                                                                                                      +
  WHERE table_name LIKE E'r_\\_view%'                                                                                                                                                                                                                                  +
  ORDER BY table_name;
 statement: SELECT table_name, is_updatable, is_insertable_into                                                                                                                                                                                                        +
   FROM information_schema.views                                                                                                                                                                                                                                       +
  WHERE table_name LIKE E'r_\\_view%'                                                                                                                                                                                                                                  +
  ORDER BY table_name;
 statement: SELECT table_name, column_name, is_updatable                                                                                                                                                                                                               +
   FROM information_schema.columns                                                                                                                                                                                                                                     +
  WHERE table_name LIKE E'r_\\_view%'                                                                                                                                                                                                                                  +
  ORDER BY table_name, ordinal_position;
 statement: SELECT events & 4 != 0 AS upd,                                                                                                                                                                                                                             +
        events & 8 != 0 AS ins,                                                                                                                                                                                                                                        +
        events & 16 != 0 AS del                                                                                                                                                                                                                                        +
   FROM pg_catalog.pg_relation_is_updatable('rw_view3'::regclass, false) t(events);
 statement: DROP TABLE base_tbl CASCADE;
 statement: CREATE TABLE base_tbl_parent (a int);
 statement: CREATE TABLE base_tbl_child (CHECK (a > 0)) INHERITS (base_tbl_parent);
 statement: INSERT INTO base_tbl_parent SELECT * FROM generate_series(-8, -1);
 statement: INSERT INTO base_tbl_child SELECT * FROM generate_series(1, 8);
 statement: CREATE VIEW rw_view1 AS SELECT * FROM base_tbl_parent;
 statement: CREATE VIEW rw_view2 AS SELECT * FROM ONLY base_tbl_parent;
 statement: SELECT * FROM rw_view1 ORDER BY a;
 statement: SELECT * FROM ONLY rw_view1 ORDER BY a;
 statement: SELECT * FROM rw_view2 ORDER BY a;
 statement: INSERT INTO rw_view1 VALUES (-100), (100);
 statement: INSERT INTO rw_view2 VALUES (-200), (200);
 statement: UPDATE rw_view1 SET a = a*10 WHERE a IN (-1, 1);
 statement: UPDATE ONLY rw_view1 SET a = a*10 WHERE a IN (-2, 2);
 statement: UPDATE rw_view2 SET a = a*10 WHERE a IN (-3, 3);
 statement: UPDATE ONLY rw_view2 SET a = a*10 WHERE a IN (-4, 4);
 statement: DELETE FROM rw_view1 WHERE a IN (-5, 5);
 statement: DELETE FROM ONLY rw_view1 WHERE a IN (-6, 6);
 statement: DELETE FROM rw_view2 WHERE a IN (-7, 7);
 statement: DELETE FROM ONLY rw_view2 WHERE a IN (-8, 8);
 statement: SELECT * FROM ONLY base_tbl_parent ORDER BY a;
 statement: SELECT * FROM base_tbl_child ORDER BY a;
 statement: DROP TABLE base_tbl_parent, base_tbl_child CASCADE;
 statement: CREATE TABLE base_tbl (a int, b int DEFAULT 10);
 statement: INSERT INTO base_tbl VALUES (1,2), (2,3), (1,-1);
 statement: CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a < b                                                                                                                                                                                                 +
   WITH LOCAL CHECK OPTION;
 statement: SELECT c.oid,                                                                                                                                                                                                                                              +
   n.nspname,                                                                                                                                                                                                                                                          +
   c.relname                                                                                                                                                                                                                                                           +
 FROM pg_catalog.pg_class c                                                                                                                                                                                                                                            +
      LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace                                                                                                                                                                                                    +
 WHERE c.relname ~ '^(rw_view1)$'                                                                                                                                                                                                                                      +
   AND pg_catalog.pg_table_is_visible(c.oid)                                                                                                                                                                                                                           +
 ORDER BY 2, 3;
 statement: SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, c.relhasoids, pg_catalog.array_to_string(c.reloptions || array(select 'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ')+
 , c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident                                                                                                                      +
 FROM pg_catalog.pg_class c                                                                                                                                                                                                                                            +
  LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)                                                                                                                                                                                                       +
 WHERE c.oid = '28746';
 statement: SELECT a.attname,                                                                                                                                                                                                                                          +
   pg_catalog.format_type(a.atttypid, a.atttypmod),                                                                                                                                                                                                                    +
   (SELECT substring(pg_catalog.pg_get_expr(d.adbin, d.adrelid) for 128)                                                                                                                                                                                               +
    FROM pg_catalog.pg_attrdef d                                                                                                                                                                                                                                       +
    WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),                                                                                                                                                                                              +
   a.attnotnull, a.attnum,                                                                                                                                                                                                                                             +
   (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t                                                                                                                                                                                             +
    WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,                                                                                                                                                         +
   NULL AS indexdef,                                                                                                                                                                                                                                                   +
   NULL AS attfdwoptions,                                                                                                                                                                                                                                              +
   a.attstorage,                                                                                                                                                                                                                                                       +
   CASE WHEN a.attstattarget=-1 THEN NULL ELSE a.attstattarget END AS attstattarget, pg_catalog.col_description(a.attrelid, a.attnum)                                                                                                                                  +
 FROM pg_catalog.pg_attribute a                                                                                                                                                                                                                                        +
 WHERE a.attrelid = '28746' AND a.attnum > 0 AND NOT a.attisdropped                                                                                                                                                                                                    +
 ORDER BY a.attnum;
 statement: SELECT pg_catalog.pg_get_viewdef('28746'::pg_catalog.oid, true);
 statement: SELECT r.rulename, trim(trailing ';' from pg_catalog.pg_get_ruledef(r.oid, true))                                                                                                                                                                          +
 FROM pg_catalog.pg_rewrite r                                                                                                                                                                                                                                          +
 WHERE r.ev_class = '28746' AND r.rulename != '_RETURN' ORDER BY 1;
 statement: SELECT * FROM information_schema.views WHERE table_name = 'rw_view1';
 statement: INSERT INTO rw_view1 VALUES(3,4);
 statement: INSERT INTO rw_view1 VALUES(4,3);
 statement: INSERT INTO rw_view1 VALUES(5,null);
 statement: UPDATE rw_view1 SET b = 5 WHERE a = 3;
 statement: UPDATE rw_view1 SET b = -5 WHERE a = 3;
 statement: INSERT INTO rw_view1(a) VALUES (9);
 statement: INSERT INTO rw_view1(a) VALUES (10);
 statement: SELECT * FROM base_tbl;
 statement: DROP TABLE base_tbl CASCADE;
 statement: CREATE TABLE base_tbl (a int);
 statement: CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a > 0;
 statement: CREATE VIEW rw_view2 AS SELECT * FROM rw_view1 WHERE a < 10                                                                                                                                                                                                +
   WITH CHECK OPTION;
 statement: SELECT c.oid,                                                                                                                                                                                                                                              +
   n.nspname,                                                                                                                                                                                                                                                          +
   c.relname                                                                                                                                                                                                                                                           +
 FROM pg_catalog.pg_class c                                                                                                                                                                                                                                            +
      LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace                                                                                                                                                                                                    +
 WHERE c.relname ~ '^(rw_view2)$'                                                                                                                                                                                                                                      +
   AND pg_catalog.pg_table_is_visible(c.oid)                                                                                                                                                                                                                           +
 ORDER BY 2, 3;
 statement: SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, c.relhasoids, pg_catalog.array_to_string(c.reloptions || array(select 'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ')+
 , c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident                                                                                                                      +
 FROM pg_catalog.pg_class c                                                                                                                                                                                                                                            +
  LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)                                                                                                                                                                                                       +
 WHERE c.oid = '28757';
 statement: SELECT a.attname,                                                                                                                                                                                                                                          +
   pg_catalog.format_type(a.atttypid, a.atttypmod),                                                                                                                                                                                                                    +
   (SELECT substring(pg_catalog.pg_get_expr(d.adbin, d.adrelid) for 128)                                                                                                                                                                                               +
    FROM pg_catalog.pg_attrdef d                                                                                                                                                                                                                                       +
    WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),                                                                                                                                                                                              +
   a.attnotnull, a.attnum,                                                                                                                                                                                                                                             +
   (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t                                                                                                                                                                                             +
    WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,                                                                                                                                                         +
   NULL AS indexdef,                                                                                                                                                                                                                                                   +
   NULL AS attfdwoptions,                                                                                                                                                                                                                                              +
   a.attstorage,                                                                                                                                                                                                                                                       +
   CASE WHEN a.attstattarget=-1 THEN NULL ELSE a.attstattarget END AS attstattarget, pg_catalog.col_description(a.attrelid, a.attnum)                                                                                                                                  +
 FROM pg_catalog.pg_attribute a                                                                                                                                                                                                                                        +
 WHERE a.attrelid = '28757' AND a.attnum > 0 AND NOT a.attisdropped                                                                                                                                                                                                    +
 ORDER BY a.attnum;
 statement: SELECT pg_catalog.pg_get_viewdef('28757'::pg_catalog.oid, true);
 statement: SELECT r.rulename, trim(trailing ';' from pg_catalog.pg_get_ruledef(r.oid, true))                                                                                                                                                                          +
 FROM pg_catalog.pg_rewrite r                                                                                                                                                                                                                                          +
 WHERE r.ev_class = '28757' AND r.rulename != '_RETURN' ORDER BY 1;
 statement: SELECT * FROM information_schema.views WHERE table_name = 'rw_view2';
 statement: INSERT INTO rw_view2 VALUES (-5);
 statement: INSERT INTO rw_view2 VALUES (5);
 statement: INSERT INTO rw_view2 VALUES (15);
 statement: SELECT * FROM base_tbl;
 statement: UPDATE rw_view2 SET a = a - 10;
 statement: UPDATE rw_view2 SET a = a + 10;
 statement: CREATE OR REPLACE VIEW rw_view2 AS SELECT * FROM rw_view1 WHERE a < 10                                                                                                                                                                                     +
   WITH LOCAL CHECK OPTION;
 statement: SELECT c.oid,                                                                                                                                                                                                                                              +
   n.nspname,                                                                                                                                                                                                                                                          +
   c.relname                                                                                                                                                                                                                                                           +
 FROM pg_catalog.pg_class c                                                                                                                                                                                                                                            +
      LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace                                                                                                                                                                                                    +
 WHERE c.relname ~ '^(rw_view2)$'                                                                                                                                                                                                                                      +
   AND pg_catalog.pg_table_is_visible(c.oid)                                                                                                                                                                                                                           +
 ORDER BY 2, 3;
 statement: SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, c.relhasoids, pg_catalog.array_to_string(c.reloptions || array(select 'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ')+
 , c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident                                                                                                                      +
 FROM pg_catalog.pg_class c                                                                                                                                                                                                                                            +
  LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)                                                                                                                                                                                                       +
 WHERE c.oid = '28757';
 statement: SELECT a.attname,                                                                                                                                                                                                                                          +
   pg_catalog.format_type(a.atttypid, a.atttypmod),                                                                                                                                                                                                                    +
   (SELECT substring(pg_catalog.pg_get_expr(d.adbin, d.adrelid) for 128)                                                                                                                                                                                               +
    FROM pg_catalog.pg_attrdef d                                                                                                                                                                                                                                       +
    WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),                                                                                                                                                                                              +
   a.attnotnull, a.attnum,                                                                                                                                                                                                                                             +
   (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t                                                                                                                                                                                             +
    WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,                                                                                                                                                         +
   NULL AS indexdef,                                                                                                                                                                                                                                                   +
   NULL AS attfdwoptions,                                                                                                                                                                                                                                              +
   a.attstorage,                                                                                                                                                                                                                                                       +
   CASE WHEN a.attstattarget=-1 THEN NULL ELSE a.attstattarget END AS attstattarget, pg_catalog.col_description(a.attrelid, a.attnum)                                                                                                                                  +
 FROM pg_catalog.pg_attribute a                                                                                                                                                                                                                                        +
 WHERE a.attrelid = '28757' AND a.attnum > 0 AND NOT a.attisdropped                                                                                                                                                                                                    +
 ORDER BY a.attnum;
 statement: SELECT pg_catalog.pg_get_viewdef('28757'::pg_catalog.oid, true);
 statement: SELECT r.rulename, trim(trailing ';' from pg_catalog.pg_get_ruledef(r.oid, true))                                                                                                                                                                          +
 FROM pg_catalog.pg_rewrite r                                                                                                                                                                                                                                          +
 WHERE r.ev_class = '28757' AND r.rulename != '_RETURN' ORDER BY 1;
 statement: SELECT * FROM information_schema.views WHERE table_name = 'rw_view2';
 statement: INSERT INTO rw_view2 VALUES (-10);
 statement: INSERT INTO rw_view2 VALUES (20);
 statement: SELECT * FROM base_tbl;
 statement: ALTER VIEW rw_view1 SET (check_option=here);
 statement: ALTER VIEW rw_view1 SET (check_option=local);
 statement: INSERT INTO rw_view2 VALUES (-20);
 statement: INSERT INTO rw_view2 VALUES (30);
 statement: ALTER VIEW rw_view2 RESET (check_option);
 statement: SELECT c.oid,                                                                                                                                                                                                                                              +
   n.nspname,                                                                                                                                                                                                                                                          +
   c.relname                                                                                                                                                                                                                                                           +
 FROM pg_catalog.pg_class c                                                                                                                                                                                                                                            +
      LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace                                                                                                                                                                                                    +
 WHERE c.relname ~ '^(rw_view2)$'                                                                                                                                                                                                                                      +
   AND pg_catalog.pg_table_is_visible(c.oid)                                                                                                                                                                                                                           +
 ORDER BY 2, 3;
 statement: SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, c.relhasoids, pg_catalog.array_to_string(c.reloptions || array(select 'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ')+
 , c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident                                                                                                                      +
 FROM pg_catalog.pg_class c                                                                                                                                                                                                                                            +
  LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)                                                                                                                                                                                                       +
 WHERE c.oid = '28757';
 statement: SELECT a.attname,                                                                                                                                                                                                                                          +
   pg_catalog.format_type(a.atttypid, a.atttypmod),                                                                                                                                                                                                                    +
   (SELECT substring(pg_catalog.pg_get_expr(d.adbin, d.adrelid) for 128)                                                                                                                                                                                               +
    FROM pg_catalog.pg_attrdef d                                                                                                                                                                                                                                       +
    WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),                                                                                                                                                                                              +
   a.attnotnull, a.attnum,                                                                                                                                                                                                                                             +
   (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t                                                                                                                                                                                             +
    WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,                                                                                                                                                         +
   NULL AS indexdef,                                                                                                                                                                                                                                                   +
   NULL AS attfdwoptions,                                                                                                                                                                                                                                              +
   a.attstorage,                                                                                                                                                                                                                                                       +
   CASE WHEN a.attstattarget=-1 THEN NULL ELSE a.attstattarget END AS attstattarget, pg_catalog.col_description(a.attrelid, a.attnum)                                                                                                                                  +
 FROM pg_catalog.pg_attribute a                                                                                                                                                                                                                                        +
 WHERE a.attrelid = '28757' AND a.attnum > 0 AND NOT a.attisdropped                                                                                                                                                                                                    +
 ORDER BY a.attnum;
 statement: SELECT pg_catalog.pg_get_viewdef('28757'::pg_catalog.oid, true);
 statement: SELECT r.rulename, trim(trailing ';' from pg_catalog.pg_get_ruledef(r.oid, true))                                                                                                                                                                          +
 FROM pg_catalog.pg_rewrite r                                                                                                                                                                                                                                          +
 WHERE r.ev_class = '28757' AND r.rulename != '_RETURN' ORDER BY 1;
 statement: SELECT * FROM information_schema.views WHERE table_name = 'rw_view2';
 statement: INSERT INTO rw_view2 VALUES (30);
 statement: SELECT * FROM base_tbl;
 statement: DROP TABLE base_tbl CASCADE;
 statement: CREATE TABLE base_tbl (a int);
 statement: CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WITH CHECK OPTION;
 statement: CREATE VIEW rw_view2 AS SELECT * FROM rw_view1 WHERE a > 0;
 statement: CREATE VIEW rw_view3 AS SELECT * FROM rw_view2 WITH CHECK OPTION;
 statement: SELECT * FROM information_schema.views WHERE table_name LIKE E'rw\\_view_' ORDER BY table_name;
 statement: INSERT INTO rw_view1 VALUES (-1);
 statement: INSERT INTO rw_view1 VALUES (1);
 statement: INSERT INTO rw_view2 VALUES (-2);
 statement: INSERT INTO rw_view2 VALUES (2);
 statement: INSERT INTO rw_view3 VALUES (-3);
 statement: INSERT INTO rw_view3 VALUES (3);
 statement: DROP TABLE base_tbl CASCADE;
 statement: CREATE TABLE base_tbl (a int, b int[]);
 statement: CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a = ANY (b)                                                                                                                                                                                           +
   WITH CHECK OPTION;
 statement: INSERT INTO rw_view1 VALUES (1, ARRAY[1,2,3]);
 statement: INSERT INTO rw_view1 VALUES (10, ARRAY[4,5]);
 statement: UPDATE rw_view1 SET b[2] = -b[2] WHERE a = 1;
 statement: UPDATE rw_view1 SET b[1] = -b[1] WHERE a = 1;
 statement: PREPARE ins(int, int[]) AS INSERT INTO rw_view1 VALUES($1, $2);
 statement: EXECUTE ins(2, ARRAY[1,2,3]);
 statement: EXECUTE ins(10, ARRAY[4,5]);
 statement: DEALLOCATE PREPARE ins;
 statement: DROP TABLE base_tbl CASCADE;
 statement: CREATE TABLE base_tbl (a int);
 statement: CREATE TABLE ref_tbl (a int PRIMARY KEY);
 statement: INSERT INTO ref_tbl SELECT * FROM generate_series(1,10);
 statement: CREATE VIEW rw_view1 AS                                                                                                                                                                                                                                    +
   SELECT * FROM base_tbl b                                                                                                                                                                                                                                            +
   WHERE EXISTS(SELECT 1 FROM ref_tbl r WHERE r.a = b.a)                                                                                                                                                                                                               +
   WITH CHECK OPTION;
 statement: INSERT INTO rw_view1 VALUES (5);
 statement: INSERT INTO rw_view1 VALUES (15);
 statement: UPDATE rw_view1 SET a = a + 5;
 statement: UPDATE rw_view1 SET a = a + 5;
 statement: EXPLAIN (costs off) INSERT INTO rw_view1 VALUES (5);
 statement: EXPLAIN (costs off) UPDATE rw_view1 SET a = a + 5;
 statement: DROP TABLE base_tbl, ref_tbl CASCADE;
 statement: CREATE TABLE base_tbl (a int, b int);
 statement: CREATE FUNCTION base_tbl_trig_fn()                                                                                                                                                                                                                         +
 RETURNS trigger AS                                                                                                                                                                                                                                                    +
 $$                                                                                                                                                                                                                                                                    +
 BEGIN                                                                                                                                                                                                                                                                 +
   NEW.b := 10;                                                                                                                                                                                                                                                        +
   RETURN NEW;                                                                                                                                                                                                                                                         +
 END;                                                                                                                                                                                                                                                                  +
 $$                                                                                                                                                                                                                                                                    +
 LANGUAGE plpgsql;
 statement: CREATE TRIGGER base_tbl_trig BEFORE INSERT OR UPDATE ON base_tbl                                                                                                                                                                                           +
   FOR EACH ROW EXECUTE PROCEDURE base_tbl_trig_fn();
 statement: CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a < b WITH CHECK OPTION;
 statement: INSERT INTO rw_view1 VALUES (5,0);
 statement: INSERT INTO rw_view1 VALUES (15, 20);
 statement: UPDATE rw_view1 SET a = 20, b = 30;
 statement: DROP TABLE base_tbl CASCADE;
 statement: DROP FUNCTION base_tbl_trig_fn();
 statement: CREATE TABLE base_tbl (a int, b int);
 statement: CREATE VIEW rw_view1 AS SELECT a FROM base_tbl WHERE a < b;
 statement: CREATE FUNCTION rw_view1_trig_fn()                                                                                                                                                                                                                         +
 RETURNS trigger AS                                                                                                                                                                                                                                                    +
 $$                                                                                                                                                                                                                                                                    +
 BEGIN                                                                                                                                                                                                                                                                 +
   IF TG_OP = 'INSERT' THEN                                                                                                                                                                                                                                            +
     INSERT INTO base_tbl VALUES (NEW.a, 10);                                                                                                                                                                                                                          +
     RETURN NEW;                                                                                                                                                                                                                                                       +
   ELSIF TG_OP = 'UPDATE' THEN                                                                                                                                                                                                                                         +
     UPDATE base_tbl SET a=NEW.a WHERE a=OLD.a;                                                                                                                                                                                                                        +
     RETURN NEW;                                                                                                                                                                                                                                                       +
   ELSIF TG_OP = 'DELETE' THEN                                                                                                                                                                                                                                         +
     DELETE FROM base_tbl WHERE a=OLD.a;                                                                                                                                                                                                                               +
     RETURN OLD;                                                                                                                                                                                                                                                       +
   END IF;                                                                                                                                                                                                                                                             +
 END;                                                                                                                                                                                                                                                                  +
 $$                                                                                                                                                                                                                                                                    +
 LANGUAGE plpgsql;
 statement: CREATE TRIGGER rw_view1_trig                                                                                                                                                                                                                               +
   INSTEAD OF INSERT OR UPDATE OR DELETE ON rw_view1                                                                                                                                                                                                                   +
   FOR EACH ROW EXECUTE PROCEDURE rw_view1_trig_fn();
 statement: CREATE VIEW rw_view2 AS                                                                                                                                                                                                                                    +
   SELECT * FROM rw_view1 WHERE a > 0 WITH LOCAL CHECK OPTION;
 statement: INSERT INTO rw_view2 VALUES (-5);
 statement: INSERT INTO rw_view2 VALUES (5);
 statement: INSERT INTO rw_view2 VALUES (50);
 statement: UPDATE rw_view2 SET a = a - 10;
 statement: SELECT * FROM base_tbl;
 statement: ALTER VIEW rw_view2 SET (check_option=cascaded);
 statement: INSERT INTO rw_view2 VALUES (100);
 statement: UPDATE rw_view2 SET a = 200 WHERE a = 5;
 statement: SELECT * FROM base_tbl;
 statement: DROP TRIGGER rw_view1_trig ON rw_view1;
 statement: CREATE RULE rw_view1_ins_rule AS ON INSERT TO rw_view1                                                                                                                                                                                                     +
   DO INSTEAD INSERT INTO base_tbl VALUES (NEW.a, 10);
 statement: CREATE RULE rw_view1_upd_rule AS ON UPDATE TO rw_view1                                                                                                                                                                                                     +
   DO INSTEAD UPDATE base_tbl SET a=NEW.a WHERE a=OLD.a;
 statement: INSERT INTO rw_view2 VALUES (-10);
 statement: INSERT INTO rw_view2 VALUES (5);
 statement: INSERT INTO rw_view2 VALUES (20);
 statement: UPDATE rw_view2 SET a = 30 WHERE a = 5;
 statement: INSERT INTO rw_view2 VALUES (5);
 statement: UPDATE rw_view2 SET a = -5 WHERE a = 5;
 statement: SELECT * FROM base_tbl;
 statement: DROP TABLE base_tbl CASCADE;
 statement: DROP FUNCTION rw_view1_trig_fn();
 statement: CREATE TABLE base_tbl (a int);
 statement: CREATE VIEW rw_view1 AS SELECT a,10 AS b FROM base_tbl;
 statement: CREATE RULE rw_view1_ins_rule AS ON INSERT TO rw_view1                                                                                                                                                                                                     +
   DO INSTEAD INSERT INTO base_tbl VALUES (NEW.a);
 statement: CREATE VIEW rw_view2 AS                                                                                                                                                                                                                                    +
   SELECT * FROM rw_view1 WHERE a > b WITH LOCAL CHECK OPTION;
 statement: INSERT INTO rw_view2 VALUES (2,3);
 statement: DROP TABLE base_tbl CASCADE;
 statement: CREATE TABLE base_tbl (person text, visibility text);
 statement: INSERT INTO base_tbl VALUES ('Tom', 'public'),                                                                                                                                                                                                             +
                             ('Dick', 'private'),                                                                                                                                                                                                                      +
                             ('Harry', 'public');
 statement: CREATE VIEW rw_view1 AS                                                                                                                                                                                                                                    +
   SELECT person FROM base_tbl WHERE visibility = 'public';
 statement: CREATE FUNCTION snoop(anyelement)                                                                                                                                                                                                                          +
 RETURNS boolean AS                                                                                                                                                                                                                                                    +
 $$                                                                                                                                                                                                                                                                    +
 BEGIN                                                                                                                                                                                                                                                                 +
   RAISE NOTICE 'snooped value: %', $1;                                                                                                                                                                                                                                +
   RETURN true;                                                                                                                                                                                                                                                        +
 END;                                                                                                                                                                                                                                                                  +
 $$                                                                                                                                                                                                                                                                    +
 LANGUAGE plpgsql COST 0.000001;
 statement: CREATE OR REPLACE FUNCTION leakproof(anyelement)                                                                                                                                                                                                           +
 RETURNS boolean AS                                                                                                                                                                                                                                                    +
 $$                                                                                                                                                                                                                                                                    +
 BEGIN                                                                                                                                                                                                                                                                 +
   RETURN true;                                                                                                                                                                                                                                                        +
 END;                                                                                                                                                                                                                                                                  +
 $$                                                                                                                                                                                                                                                                    +
 LANGUAGE plpgsql STRICT IMMUTABLE LEAKPROOF;
 statement: SELECT * FROM rw_view1 WHERE snoop(person);
 statement: UPDATE rw_view1 SET person=person WHERE snoop(person);
 statement: DELETE FROM rw_view1 WHERE NOT snoop(person);
 statement: ALTER VIEW rw_view1 SET (security_barrier = true);
 statement: SELECT table_name, is_insertable_into                                                                                                                                                                                                                      +
   FROM information_schema.tables                                                                                                                                                                                                                                      +
  WHERE table_name = 'rw_view1';
 statement: SELECT table_name, is_updatable, is_insertable_into                                                                                                                                                                                                        +
   FROM information_schema.views                                                                                                                                                                                                                                       +
  WHERE table_name = 'rw_view1';
 statement: SELECT table_name, column_name, is_updatable                                                                                                                                                                                                               +
   FROM information_schema.columns                                                                                                                                                                                                                                     +
  WHERE table_name = 'rw_view1'                                                                                                                                                                                                                                        +
  ORDER BY ordinal_position;
 statement: SELECT * FROM rw_view1 WHERE snoop(person);
 statement: UPDATE rw_view1 SET person=person WHERE snoop(person);
 statement: DELETE FROM rw_view1 WHERE NOT snoop(person);
 statement: EXPLAIN (costs off) SELECT * FROM rw_view1 WHERE snoop(person);
 statement: EXPLAIN (costs off) UPDATE rw_view1 SET person=person WHERE snoop(person);
 statement: EXPLAIN (costs off) DELETE FROM rw_view1 WHERE NOT snoop(person);
 statement: CREATE VIEW rw_view2 WITH (security_barrier = true) AS                                                                                                                                                                                                     +
   SELECT * FROM rw_view1 WHERE snoop(person);
 statement: SELECT table_name, is_insertable_into                                                                                                                                                                                                                      +
   FROM information_schema.tables                                                                                                                                                                                                                                      +
  WHERE table_name = 'rw_view2';
 statement: SELECT table_name, is_updatable, is_insertable_into                                                                                                                                                                                                        +
   FROM information_schema.views                                                                                                                                                                                                                                       +
  WHERE table_name = 'rw_view2';
 statement: SELECT table_name, column_name, is_updatable                                                                                                                                                                                                               +
   FROM information_schema.columns                                                                                                                                                                                                                                     +
  WHERE table_name = 'rw_view2'                                                                                                                                                                                                                                        +
  ORDER BY ordinal_position;
 statement: SELECT * FROM rw_view2 WHERE snoop(person);
 statement: UPDATE rw_view2 SET person=person WHERE snoop(person);
 statement: DELETE FROM rw_view2 WHERE NOT snoop(person);
 statement: EXPLAIN (costs off) SELECT * FROM rw_view2 WHERE snoop(person);
 statement: EXPLAIN (costs off) UPDATE rw_view2 SET person=person WHERE snoop(person);
 statement: EXPLAIN (costs off) DELETE FROM rw_view2 WHERE NOT snoop(person);
 statement: DROP TABLE base_tbl CASCADE;
 statement: CREATE TABLE base_tbl(id int PRIMARY KEY, data text, deleted boolean);
 statement: INSERT INTO base_tbl VALUES (1, 'Row 1', false), (2, 'Row 2', true);
 statement: CREATE RULE base_tbl_ins_rule AS ON INSERT TO base_tbl                                                                                                                                                                                                     +
   WHERE EXISTS (SELECT 1 FROM base_tbl t WHERE t.id = new.id)                                                                                                                                                                                                         +
   DO INSTEAD                                                                                                                                                                                                                                                          +
     UPDATE base_tbl SET data = new.data, deleted = false WHERE id = new.id;
 statement: CREATE RULE base_tbl_del_rule AS ON DELETE TO base_tbl                                                                                                                                                                                                     +
   DO INSTEAD                                                                                                                                                                                                                                                          +
     UPDATE base_tbl SET deleted = true WHERE id = old.id;
 statement: CREATE VIEW rw_view1 WITH (security_barrier=true) AS                                                                                                                                                                                                       +
   SELECT id, data FROM base_tbl WHERE NOT deleted;
 statement: SELECT * FROM rw_view1;
 statement: EXPLAIN (costs off) DELETE FROM rw_view1 WHERE id = 1 AND snoop(data);
 statement: DELETE FROM rw_view1 WHERE id = 1 AND snoop(data);
 statement: EXPLAIN (costs off) INSERT INTO rw_view1 VALUES (2, 'New row 2');
 statement: INSERT INTO rw_view1 VALUES (2, 'New row 2');
 statement: SELECT * FROM base_tbl;
 statement: DROP TABLE base_tbl CASCADE;
 statement: CREATE TABLE t1 (a int, b float, c text);
 statement: CREATE INDEX t1_a_idx ON t1(a);
 statement: INSERT INTO t1                                                                                                                                                                                                                                             +
 SELECT i,i,'t1' FROM generate_series(1,10) g(i);
 statement: ANALYZE t1;
 statement: CREATE TABLE t11 (d text) INHERITS (t1);
 statement: CREATE INDEX t11_a_idx ON t11(a);
 statement: INSERT INTO t11                                                                                                                                                                                                                                            +
 SELECT i,i,'t11','t11d' FROM generate_series(1,10) g(i);
 statement: ANALYZE t11;
 statement: CREATE TABLE t12 (e int[]) INHERITS (t1);
 statement: CREATE INDEX t12_a_idx ON t12(a);
 statement: INSERT INTO t12                                                                                                                                                                                                                                            +
 SELECT i,i,'t12','{1,2}'::int[] FROM generate_series(1,10) g(i);
 statement: ANALYZE t12;
 statement: CREATE TABLE t111 () INHERITS (t11, t12);
 statement: CREATE INDEX t111_a_idx ON t111(a);
 statement: INSERT INTO t111                                                                                                                                                                                                                                           +
 SELECT i,i,'t111','t111d','{1,1,1}'::int[] FROM generate_series(1,10) g(i);
 statement: ANALYZE t111;
 statement: CREATE VIEW v1 WITH (security_barrier=true) AS                                                                                                                                                                                                             +
 SELECT *, (SELECT d FROM t11 WHERE t11.a = t1.a LIMIT 1) AS d                                                                                                                                                                                                         +
 FROM t1                                                                                                                                                                                                                                                               +
 WHERE a > 5 AND EXISTS(SELECT 1 FROM t12 WHERE t12.a = t1.a);
 statement: SELECT * FROM v1 WHERE a=3;
 statement: SELECT * FROM v1 WHERE a=8;
 statement: EXPLAIN (VERBOSE, COSTS OFF)                                                                                                                                                                                                                               +
 UPDATE v1 SET a=100 WHERE snoop(a) AND leakproof(a) AND a = 3;
 statement: UPDATE v1 SET a=100 WHERE snoop(a) AND leakproof(a) AND a = 3;
 statement: SELECT * FROM v1 WHERE a=100;
 statement: SELECT * FROM t1 WHERE a=100;
 statement: EXPLAIN (VERBOSE, COSTS OFF)                                                                                                                                                                                                                               +
 UPDATE v1 SET a=a+1 WHERE snoop(a) AND leakproof(a) AND a = 8;
 statement: UPDATE v1 SET a=a+1 WHERE snoop(a) AND leakproof(a) AND a = 8;
 statement: SELECT * FROM v1 WHERE b=8;
 statement: DELETE FROM v1 WHERE snoop(a) AND leakproof(a);
 statement: TABLE t1;
 statement: DROP TABLE t1, t11, t12, t111 CASCADE;
 statement: DROP FUNCTION snoop(anyelement);
 statement: DROP FUNCTION leakproof(anyelement);
 statement: CREATE TABLE tx1 (a integer);
 statement: CREATE TABLE tx2 (b integer);
 statement: CREATE TABLE tx3 (c integer);
 statement: CREATE VIEW vx1 AS SELECT a FROM tx1 WHERE EXISTS(SELECT 1 FROM tx2 JOIN tx3 ON b=c);
 statement: INSERT INTO vx1 values (1);
 statement: SELECT * FROM tx1;
 statement: SELECT * FROM vx1;
 statement: DROP VIEW vx1;
 statement: DROP TABLE tx1;
 statement: DROP TABLE tx2;
 statement: DROP TABLE tx3;
 statement: CREATE TABLE tx1 (a integer);
 statement: CREATE TABLE tx2 (b integer);
 statement: CREATE TABLE tx3 (c integer);
 statement: CREATE VIEW vx1 AS SELECT a FROM tx1 WHERE EXISTS(SELECT 1 FROM tx2 JOIN tx3 ON b=c);
 statement: INSERT INTO vx1 VALUES (1);
 statement: INSERT INTO vx1 VALUES (1);
 statement: SELECT * FROM tx1;
 statement: SELECT * FROM vx1;
 statement: DROP VIEW vx1;
 statement: DROP TABLE tx1;
 statement: DROP TABLE tx2;
 statement: DROP TABLE tx3;
 statement: CREATE TABLE tx1 (a integer, b integer);
 statement: CREATE TABLE tx2 (b integer, c integer);
 statement: CREATE TABLE tx3 (c integer, d integer);
 statement: ALTER TABLE tx1 DROP COLUMN b;
 statement: ALTER TABLE tx2 DROP COLUMN c;
 statement: ALTER TABLE tx3 DROP COLUMN d;
 statement: CREATE VIEW vx1 AS SELECT a FROM tx1 WHERE EXISTS(SELECT 1 FROM tx2 JOIN tx3 ON b=c);
 statement: INSERT INTO vx1 VALUES (1);
 statement: INSERT INTO vx1 VALUES (1);
 statement: SELECT * FROM tx1;
 statement: SELECT * FROM vx1;
 statement: DROP VIEW vx1;
 statement: DROP TABLE tx1;
 statement: DROP TABLE tx2;
 statement: DROP TABLE tx3;
 statement: CREATE TABLE t1 (a int, b text, c int);
 statement: INSERT INTO t1 VALUES (1, 'one', 10);
 statement: CREATE TABLE t2 (cc int);
 statement: INSERT INTO t2 VALUES (10), (20);
 statement: CREATE VIEW v1 WITH (security_barrier = true) AS                                                                                                                                                                                                           +
   SELECT * FROM t1 WHERE (a > 0)                                                                                                                                                                                                                                      +
   WITH CHECK OPTION;
 statement: CREATE VIEW v2 WITH (security_barrier = true) AS                                                                                                                                                                                                           +
   SELECT * FROM v1 WHERE EXISTS (SELECT 1 FROM t2 WHERE t2.cc = v1.c)                                                                                                                                                                                                 +
   WITH CHECK OPTION;
 statement: INSERT INTO v2 VALUES (2, 'two', 20);
 statement: INSERT INTO v2 VALUES (-2, 'minus two', 20);
 statement: INSERT INTO v2 VALUES (3, 'three', 30);
 statement: UPDATE v2 SET b = 'ONE' WHERE a = 1;
 statement: UPDATE v2 SET a = -1 WHERE a = 1;
 statement: UPDATE v2 SET c = 30 WHERE a = 1;
 statement: DELETE FROM v2 WHERE a = 2;
 statement: SELECT * FROM v2;
 statement: DROP VIEW v2;
 statement: DROP VIEW v1;
 statement: DROP TABLE t2;
 statement: DROP TABLE t1;
 statement: CREATE TABLE t1 (a int, b text);
 statement: CREATE VIEW v1 AS SELECT null::int AS a;
 statement: CREATE OR REPLACE VIEW v1 AS SELECT * FROM t1 WHERE a > 0 WITH CHECK OPTION;
 statement: INSERT INTO v1 VALUES (1, 'ok');
 statement: INSERT INTO v1 VALUES (-1, 'invalid');
 statement: DROP VIEW v1;
 statement: DROP TABLE t1;

