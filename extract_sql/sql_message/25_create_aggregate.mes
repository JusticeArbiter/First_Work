LOG:  statement: select message from postgres_log where query is null;
 statement: CREATE AGGREGATE newavg (                                                     +
    sfunc = int4_avg_accum, basetype = int4, stype = _int8,                               +
    finalfunc = int8_avg,                                                                 +
    initcond1 = '{0,0}'                                                                   +
 );
 statement: COMMENT ON AGGREGATE newavg_wrong (int4) IS 'an agg comment';
 statement: COMMENT ON AGGREGATE newavg (int4) IS 'an agg comment';
 statement: COMMENT ON AGGREGATE newavg (int4) IS NULL;
 statement: CREATE AGGREGATE newsum (                                                     +
    sfunc1 = int4pl, basetype = int4, stype1 = int4,                                      +
    initcond1 = '0'                                                                       +
 );
 statement: CREATE AGGREGATE newcnt (*) (                                                 +
    sfunc = int8inc, stype = int8,                                                        +
    initcond = '0'                                                                        +
 );
 statement: CREATE AGGREGATE oldcnt (                                                     +
    sfunc = int8inc, basetype = 'ANY', stype = int8,                                      +
    initcond = '0'                                                                        +
 );
 statement: CREATE AGGREGATE newcnt ("any") (                                             +
    sfunc = int8inc_any, stype = int8,                                                    +
    initcond = '0'                                                                        +
 );
 statement: COMMENT ON AGGREGATE nosuchagg (*) IS 'should fail';
 statement: COMMENT ON AGGREGATE newcnt (*) IS 'an agg(*) comment';
 statement: COMMENT ON AGGREGATE newcnt ("any") IS 'an agg(any) comment';
 statement: create function sum3(int8,int8,int8) returns int8 as                          +
 'select $1 + $2 + $3' language sql strict immutable;
 statement: create aggregate sum2(int8,int8) (                                            +
    sfunc = sum3, stype = int8,                                                           +
    initcond = '0'                                                                        +
 );
 statement: create type aggtype as (a integer, b integer, c text);
 statement: create function aggf_trans(aggtype[],integer,integer,text) returns aggtype[]  +
 as 'select array_append($1,ROW($2,$3,$4)::aggtype)'                                      +
 language sql strict immutable;
 statement: create function aggfns_trans(aggtype[],integer,integer,text) returns aggtype[]+
 as 'select array_append($1,ROW($2,$3,$4)::aggtype)'                                      +
 language sql immutable;
 statement: create aggregate aggfstr(integer,integer,text) (                              +
    sfunc = aggf_trans, stype = aggtype[],                                                +
    initcond = '{}'                                                                       +
 );
 statement: create aggregate aggfns(integer,integer,text) (                               +
    sfunc = aggfns_trans, stype = aggtype[], sspace = 10000,                              +
    initcond = '{}'                                                                       +
 );
 statement: create function least_accum(anyelement, variadic anyarray)                    +
 returns anyelement language sql as                                                       +
   'select least($1, min($2[i])) from generate_subscripts($2,1) g(i)';
 statement: create aggregate least_agg(variadic items anyarray) (                         +
   stype = anyelement, sfunc = least_accum                                                +
 );
 statement: create aggregate my_percentile_disc(float8 ORDER BY anyelement) (             +
   stype = internal,                                                                      +
   sfunc = ordered_set_transition,                                                        +
   finalfunc = percentile_disc_final,                                                     +
   finalfunc_extra = true                                                                 +
 );
 statement: create aggregate my_rank(VARIADIC "any" ORDER BY VARIADIC "any") (            +
   stype = internal,                                                                      +
   sfunc = ordered_set_transition_multi,                                                  +
   finalfunc = rank_final,                                                                +
   finalfunc_extra = true,                                                                +
   hypothetical                                                                           +
 );
 statement: alter aggregate my_percentile_disc(float8 ORDER BY anyelement)                +
   rename to test_percentile_disc;
 statement: alter aggregate my_rank(VARIADIC "any" ORDER BY VARIADIC "any")               +
   rename to test_rank;
 statement: SELECT n.nspname as "Schema",                                                 +
   p.proname AS "Name",                                                                   +
   pg_catalog.format_type(p.prorettype, NULL) AS "Result data type",                      +
   CASE WHEN p.pronargs = 0                                                               +
     THEN CAST('*' AS pg_catalog.text)                                                    +
     ELSE pg_catalog.pg_get_function_arguments(p.oid)                                     +
   END AS "Argument data types",                                                          +
   pg_catalog.obj_description(p.oid, 'pg_proc') as "Description"                          +
 FROM pg_catalog.pg_proc p                                                                +
      LEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace                       +
 WHERE p.proisagg                                                                         +
   AND p.proname ~ '^(test_.*)$'                                                          +
   AND pg_catalog.pg_function_is_visible(p.oid)                                           +
 ORDER BY 1, 2, 4;
 statement: CREATE AGGREGATE sumdouble (float8)                                           +
 (                                                                                        +
     stype = float8,                                                                      +
     sfunc = float8pl,                                                                    +
     mstype = float8,                                                                     +
     msfunc = float8pl,                                                                   +
     minvfunc = float8mi                                                                  +
 );
 statement: CREATE FUNCTION float8mi_n(float8, float8) RETURNS float8 AS                  +
 $$ SELECT $1 - $2; $$                                                                    +
 LANGUAGE SQL;
 statement: CREATE AGGREGATE invalidsumdouble (float8)                                    +
 (                                                                                        +
     stype = float8,                                                                      +
     sfunc = float8pl,                                                                    +
     mstype = float8,                                                                     +
     msfunc = float8pl,                                                                   +
     minvfunc = float8mi_n                                                                +
 );
 statement: CREATE FUNCTION float8mi_int(float8, float8) RETURNS int AS                   +
 $$ SELECT CAST($1 - $2 AS INT); $$                                                       +
 LANGUAGE SQL;
 statement: CREATE AGGREGATE wrongreturntype (float8)                                     +
 (                                                                                        +
     stype = float8,                                                                      +
     sfunc = float8pl,                                                                    +
     mstype = float8,                                                                     +
     msfunc = float8pl,                                                                   +
     minvfunc = float8mi_int                                                              +
 );

