LOG:  statement: select message from postgres_log where query is null;
 statement: create table insertconflicttest(key int4, fruit text);
 statement: create unique index op_index_key on insertconflicttest(key, fruit text_pattern_ops);
 statement: create unique index collation_index_key on insertconflicttest(key, fruit collate "C");
 statement: create unique index both_index_key on insertconflicttest(key, fruit collate "C" text_pattern_ops);
 statement: create unique index both_index_expr_key on insertconflicttest(key, lower(fruit) collate "C" text_pattern_ops);
 statement: explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (key) do nothing;
 statement: explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (fruit) do nothing;
 statement: explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (key, fruit) do nothing;
 statement: explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (fruit, key, fruit, key) do nothing;
 statement: explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (lower(fruit), key, lower(fruit), key) do nothing;
 statement: explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (key, fruit) do update set fruit = excluded.fruit                                                            +
   where exists (select 1 from insertconflicttest ii where ii.key = excluded.key);
 statement: explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (key, fruit text_pattern_ops) do nothing;
 statement: explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (key, fruit collate "C") do nothing;
 statement: explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (fruit collate "C" text_pattern_ops, key) do nothing;
 statement: explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (lower(fruit) collate "C", key, key) do nothing;
 statement: explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (fruit, key, fruit text_pattern_ops, key) do nothing;
 statement: explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (lower(fruit) collate "C" text_pattern_ops, key, key) do nothing;
 statement: drop index op_index_key;
 statement: drop index collation_index_key;
 statement: drop index both_index_key;
 statement: drop index both_index_expr_key;
 statement: create unique index cross_match on insertconflicttest(lower(fruit) collate "C", upper(fruit) text_pattern_ops);
 statement: explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (lower(fruit) text_pattern_ops, upper(fruit) collate "C") do nothing;
 statement: explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (lower(fruit) collate "C", upper(fruit) text_pattern_ops) do nothing;
 statement: drop index cross_match;
 statement: create unique index key_index on insertconflicttest(key);
 statement: explain (costs off) insert into insertconflicttest values (0, 'Bilberry') on conflict (key) do update set fruit = excluded.fruit;
 statement: explain (costs off) insert into insertconflicttest values (0, 'Bilberry') on conflict (key) do update set fruit = excluded.fruit where insertconflicttest.fruit != 'Cawesh';
 statement: explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (key) do update set fruit = excluded.fruit where excluded.fruit != 'Elderberry';
 statement: explain (costs off, format json) insert into insertconflicttest values (0, 'Bilberry') on conflict (key) do update set fruit = excluded.fruit where insertconflicttest.fruit != 'Lime' returning *;
 statement: insert into insertconflicttest values (1, 'Apple') on conflict do update set fruit = excluded.fruit;
 statement: insert into insertconflicttest values (1, 'Apple') on conflict (key) do update set fruit = excluded.fruit;
 statement: insert into insertconflicttest values (2, 'Orange') on conflict (key, key, key) do update set fruit = excluded.fruit;
 statement: insert into insertconflicttest                                                                                                                                                                     +
 values (1, 'Apple'), (2, 'Orange')                                                                                                                                                                            +
 on conflict (key) do update set (fruit, key) = (excluded.fruit, excluded.key);
 statement: insert into insertconflicttest values (1, 'Apple') on conflict (key) do update set fruit = excluded.fruit RETURNING excluded.fruit;
 statement: insert into insertconflicttest values (1, 'Apple') on conflict (keyy) do update set fruit = excluded.fruit;
 statement: insert into insertconflicttest values (1, 'Apple') on conflict (key) do update set fruit = excluded.fruitt;
 statement: insert into insertconflicttest values (3, 'Kiwi') on conflict (key, fruit) do update set fruit = excluded.fruit;
 statement: insert into insertconflicttest values (4, 'Mango') on conflict (fruit, key) do update set fruit = excluded.fruit;
 statement: insert into insertconflicttest values (5, 'Lemon') on conflict (fruit) do update set fruit = excluded.fruit;
 statement: insert into insertconflicttest values (6, 'Passionfruit') on conflict (lower(fruit)) do update set fruit = excluded.fruit;
 statement: insert into insertconflicttest AS ict values (6, 'Passionfruit') on conflict (key) do update set fruit = excluded.fruit;
 statement: insert into insertconflicttest AS ict values (6, 'Passionfruit') on conflict (key) do update set fruit = ict.fruit;
 statement: insert into insertconflicttest AS ict values (6, 'Passionfruit') on conflict (key) do update set fruit = insertconflicttest.fruit;
 statement: drop index key_index;
 statement: create unique index comp_key_index on insertconflicttest(key, fruit);
 statement: insert into insertconflicttest values (7, 'Raspberry') on conflict (key, fruit) do update set fruit = excluded.fruit;
 statement: insert into insertconflicttest values (8, 'Lime') on conflict (fruit, key) do update set fruit = excluded.fruit;
 statement: insert into insertconflicttest values (9, 'Banana') on conflict (key) do update set fruit = excluded.fruit;
 statement: insert into insertconflicttest values (10, 'Blueberry') on conflict (key, key, key) do update set fruit = excluded.fruit;
 statement: insert into insertconflicttest values (11, 'Cherry') on conflict (key, lower(fruit)) do update set fruit = excluded.fruit;
 statement: insert into insertconflicttest values (12, 'Date') on conflict (lower(fruit), key) do update set fruit = excluded.fruit;
 statement: drop index comp_key_index;
 statement: create unique index part_comp_key_index on insertconflicttest(key, fruit) where key < 5;
 statement: create unique index expr_part_comp_key_index on insertconflicttest(key, lower(fruit)) where key < 5;
 statement: insert into insertconflicttest values (13, 'Grape') on conflict (key, fruit) do update set fruit = excluded.fruit;
 statement: insert into insertconflicttest values (14, 'Raisin') on conflict (fruit, key) do update set fruit = excluded.fruit;
 statement: insert into insertconflicttest values (15, 'Cranberry') on conflict (key) do update set fruit = excluded.fruit;
 statement: insert into insertconflicttest values (16, 'Melon') on conflict (key, key, key) do update set fruit = excluded.fruit;
 statement: insert into insertconflicttest values (17, 'Mulberry') on conflict (key, lower(fruit)) do update set fruit = excluded.fruit;
 statement: insert into insertconflicttest values (18, 'Pineapple') on conflict (lower(fruit), key) do update set fruit = excluded.fruit;
 statement: drop index part_comp_key_index;
 statement: drop index expr_part_comp_key_index;
 statement: create unique index expr_key_index on insertconflicttest(lower(fruit));
 statement: insert into insertconflicttest values (20, 'Quince') on conflict (lower(fruit)) do update set fruit = excluded.fruit;
 statement: insert into insertconflicttest values (21, 'Pomegranate') on conflict (lower(fruit), lower(fruit)) do update set fruit = excluded.fruit;
 statement: insert into insertconflicttest values (22, 'Apricot') on conflict (upper(fruit)) do update set fruit = excluded.fruit;
 statement: insert into insertconflicttest values (23, 'Blackberry') on conflict (fruit) do update set fruit = excluded.fruit;
 statement: drop index expr_key_index;
 statement: create unique index expr_comp_key_index on insertconflicttest(key, lower(fruit));
 statement: create unique index tricky_expr_comp_key_index on insertconflicttest(key, lower(fruit), upper(fruit));
 statement: insert into insertconflicttest values (24, 'Plum') on conflict (key, lower(fruit)) do update set fruit = excluded.fruit;
 statement: insert into insertconflicttest values (25, 'Peach') on conflict (lower(fruit), key) do update set fruit = excluded.fruit;
 statement: explain (costs off) insert into insertconflicttest values (26, 'Fig') on conflict (lower(fruit), key, lower(fruit), key) do update set fruit = excluded.fruit;
 statement: insert into insertconflicttest values (27, 'Prune') on conflict (key, upper(fruit)) do update set fruit = excluded.fruit;
 statement: insert into insertconflicttest values (28, 'Redcurrant') on conflict (fruit, key) do update set fruit = excluded.fruit;
 statement: insert into insertconflicttest values (29, 'Nectarine') on conflict (key) do update set fruit = excluded.fruit;
 statement: drop index expr_comp_key_index;
 statement: drop index tricky_expr_comp_key_index;
 statement: create unique index key_index on insertconflicttest(key);
 statement: create unique index fruit_index on insertconflicttest(fruit);
 statement: insert into insertconflicttest values (26, 'Fig') on conflict (key) do update set fruit = excluded.fruit;
 statement: insert into insertconflicttest values (26, 'Peach') on conflict (key) do update set fruit = excluded.fruit;
 statement: insert into insertconflicttest values (25, 'Fig') on conflict (fruit) do update set fruit = excluded.fruit;
 statement: drop index key_index;
 statement: drop index fruit_index;
 statement: create unique index partial_key_index on insertconflicttest(key) where fruit like '%berry';
 statement: insert into insertconflicttest values (23, 'Blackberry') on conflict (key) where fruit like '%berry' do update set fruit = excluded.fruit;
 statement: insert into insertconflicttest values (23, 'Blackberry') on conflict (key) where fruit like '%berry' and fruit = 'inconsequential' do nothing;
 statement: insert into insertconflicttest values (23, 'Blackberry') on conflict (key) do update set fruit = excluded.fruit;
 statement: insert into insertconflicttest values (23, 'Blackberry') on conflict (key) where fruit like '%berry' or fruit = 'consequential' do nothing;
 statement: insert into insertconflicttest values (23, 'Blackberry') on conflict (fruit) where fruit like '%berry' do update set fruit = excluded.fruit;
 statement: drop index partial_key_index;
 statement: create unique index plain on insertconflicttest(key);
 statement: insert into insertconflicttest as i values (23, 'Jackfruit') on conflict (key) do update set fruit = excluded.fruit                                                                                +
   where i.* != excluded.* returning *;
 statement: insert into insertconflicttest as i values (23, 'Jackfruit') on conflict (key) do update set fruit = excluded.fruit                                                                                +
   where i.* != excluded.* returning *;
 statement: insert into insertconflicttest as i values (23, 'Jackfruit') on conflict (key) do update set fruit = excluded.fruit                                                                                +
   where i.* = excluded.* returning *;
 statement: insert into insertconflicttest as i values (23, 'Avocado') on conflict (key) do update set fruit = excluded.*::text                                                                                +
   returning *;
 statement: explain (costs off) insert into insertconflicttest as i values (23, 'Avocado') on conflict (key) do update set fruit = excluded.fruit where excluded.* is null;
 statement: explain (costs off) insert into insertconflicttest as i values (23, 'Avocado') on conflict (key) do update set fruit = excluded.*::text;
 statement: drop index plain;
 statement: drop table insertconflicttest;
 statement: create table syscolconflicttest(key int4, data text) WITH OIDS;
 statement: insert into syscolconflicttest values (1);
 statement: insert into syscolconflicttest values (1) on conflict (key) do update set data = excluded.ctid::text;
 statement: insert into syscolconflicttest values (1) on conflict (key) do update set data = excluded.oid::text;
 statement: drop table syscolconflicttest;
 statement: create table insertconflict (a bigint, b bigint);
 statement: create unique index insertconflicti1 on insertconflict(coalesce(a, 0));
 statement: create unique index insertconflicti2 on insertconflict(b)                                                                                                                                          +
   where coalesce(a, 1) > 0;
 statement: insert into insertconflict values (1, 2)                                                                                                                                                           +
 on conflict (coalesce(a, 0)) do nothing;
 statement: insert into insertconflict values (1, 2)                                                                                                                                                           +
 on conflict (b) where coalesce(a, 1) > 0 do nothing;
 statement: insert into insertconflict values (1, 2)                                                                                                                                                           +
 on conflict (b) where coalesce(a, 1) > 1 do nothing;
 statement: drop table insertconflict;
 statement: create table insertconflict (f1 int primary key, f2 text);
 statement: create view insertconflictv as                                                                                                                                                                     +
   select * from insertconflict with cascaded check option;
 statement: insert into insertconflictv values (1,'foo')                                                                                                                                                       +
   on conflict (f1) do update set f2 = excluded.f2;
 statement: select * from insertconflict;
 statement: insert into insertconflictv values (1,'bar')                                                                                                                                                       +
   on conflict (f1) do update set f2 = excluded.f2;
 statement: select * from insertconflict;
 statement: drop view insertconflictv;
 statement: drop table insertconflict;
 statement: create table cities (                                                                                                                                                                              +
         name            text,                                                                                                                                                                                 +
         population      float8,                                                                                                                                                                               +
         altitude        int                                                                                                                                                                                   +
 );
 statement: create table capitals (                                                                                                                                                                            +
         state           char(2)                                                                                                                                                                               +
 ) inherits (cities);
 statement: create unique index cities_names_unique on cities (name);
 statement: create unique index capitals_names_unique on capitals (name);
 statement: insert into cities values ('San Francisco', 7.24E+5, 63);
 statement: insert into cities values ('Las Vegas', 2.583E+5, 2174);
 statement: insert into cities values ('Mariposa', 1200, 1953);
 statement: insert into capitals values ('Sacramento', 3.694E+5, 30, 'CA');
 statement: insert into capitals values ('Madison', 1.913E+5, 845, 'WI');
 statement: select * from capitals;
 statement: insert into cities values ('Las Vegas', 2.583E+5, 2174) on conflict do nothing;
 statement: insert into capitals values ('Sacramento', 4664.E+5, 30, 'CA') on conflict (name) do update set population = excluded.population;
 statement: insert into capitals values ('Sacramento', 50, 2267, 'NE') on conflict (name) do nothing;
 statement: select * from capitals;
 statement: insert into cities values ('Las Vegas', 5.83E+5, 2001) on conflict (name) do update set population = excluded.population, altitude = excluded.altitude;
 statement: select tableoid::regclass, * from cities;
 statement: insert into capitals values ('Las Vegas', 5.83E+5, 2222, 'NV') on conflict (name) do update set population = excluded.population;
 statement: select * from capitals;
 statement: select tableoid::regclass, * from cities;
 statement: insert into cities values ('Las Vegas', 5.86E+5, 2223) on conflict (name) do update set population = excluded.population, altitude = excluded.altitude;
 statement: select tableoid::regclass, * from cities;
 statement: drop table capitals;
 statement: drop table cities;
 statement: create table excluded(key int primary key, data text);
 statement: insert into excluded values(1, '1');
 statement: insert into excluded values(1, '2') on conflict (key) do update set data = excluded.data RETURNING *;
 statement: insert into excluded AS target values(1, '2') on conflict (key) do update set data = excluded.data RETURNING *;
 statement: insert into excluded AS target values(1, '2') on conflict (key) do update set data = target.data RETURNING *;
 statement: insert into excluded values(1, '2') on conflict (key) do update set data = 3 RETURNING excluded.*;
 statement: drop table excluded;
 statement: create table testoids(key int primary key, data text) without oids;
 statement: insert into testoids values(1, '1') on conflict (key) do update set data = excluded.data RETURNING *;
 statement: insert into testoids values(1, '2') on conflict (key) do update set data = excluded.data RETURNING *;
 statement: alter table testoids set with oids;
 statement: insert into testoids values(1, '3') on conflict (key) do update set data = excluded.data RETURNING *;
 statement: insert into testoids values(2, '1') on conflict (key) do update set data = excluded.data RETURNING *;
 statement: insert into testoids values(2, '2') on conflict (key) do update set data = excluded.data RETURNING *;
 statement: alter table testoids set without oids;
 statement: insert into testoids values(1, '4') on conflict (key) do update set data = excluded.data RETURNING *;
 statement: insert into testoids values(3, '1') on conflict (key) do update set data = excluded.data RETURNING *;
 statement: insert into testoids values(3, '2') on conflict (key) do update set data = excluded.data RETURNING *;
 statement: DROP TABLE testoids;
 statement: create table dropcol(key int primary key, drop1 int, keep1 text, drop2 numeric, keep2 float);
 statement: insert into dropcol(key, drop1, keep1, drop2, keep2) values(1, 1, '1', '1', 1);
 statement: insert into dropcol(key, drop1, keep1, drop2, keep2) values(1, 2, '2', '2', 2) on conflict(key)                                                                                                    +
     do update set drop1 = excluded.drop1, keep1 = excluded.keep1, drop2 = excluded.drop2, keep2 = excluded.keep2                                                                                              +
     where excluded.drop1 is not null and excluded.keep1 is not null and excluded.drop2 is not null and excluded.keep2 is not null                                                                             +
           and dropcol.drop1 is not null and dropcol.keep1 is not null and dropcol.drop2 is not null and dropcol.keep2 is not null                                                                             +
     returning *;
 statement: ;
 statement: insert into dropcol(key, drop1, keep1, drop2, keep2) values(1, 3, '3', '3', 3) on conflict(key)                                                                                                    +
     do update set drop1 = dropcol.drop1, keep1 = dropcol.keep1, drop2 = dropcol.drop2, keep2 = dropcol.keep2                                                                                                  +
     returning *;
 statement: ;
 statement: alter table dropcol drop column drop1, drop column drop2;
 statement: insert into dropcol(key, keep1, keep2) values(1, '4', 4) on conflict(key)                                                                                                                          +
     do update set keep1 = excluded.keep1, keep2 = excluded.keep2                                                                                                                                              +
     where excluded.keep1 is not null and excluded.keep2 is not null                                                                                                                                           +
           and dropcol.keep1 is not null and dropcol.keep2 is not null                                                                                                                                         +
     returning *;
 statement: ;
 statement: insert into dropcol(key, keep1, keep2) values(1, '5', 5) on conflict(key)                                                                                                                          +
     do update set keep1 = dropcol.keep1, keep2 = dropcol.keep2                                                                                                                                                +
     returning *;
 statement: ;
 statement: DROP TABLE dropcol;
 statement: create table twoconstraints (f1 int unique, f2 box,                                                                                                                                                +
                              exclude using gist(f2 with &&));
 statement: insert into twoconstraints values(1, '((0,0),(1,1))');
 statement: insert into twoconstraints values(1, '((2,2),(3,3))');
 statement: insert into twoconstraints values(2, '((0,0),(1,2))');
 statement: insert into twoconstraints values(2, '((0,0),(1,2))')                                                                                                                                              +
   on conflict on constraint twoconstraints_f1_key do nothing;
 statement: insert into twoconstraints values(2, '((0,0),(1,2))')                                                                                                                                              +
   on conflict on constraint twoconstraints_f2_excl do nothing;
 statement: select * from twoconstraints;
 statement: drop table twoconstraints;
 statement: create table selfconflict (f1 int primary key, f2 int);
 statement: begin transaction isolation level read committed;
 statement: insert into selfconflict values (1,1), (1,2) on conflict do nothing;
 statement: commit;
 statement: begin transaction isolation level repeatable read;
 statement: insert into selfconflict values (2,1), (2,2) on conflict do nothing;
 statement: commit;
 statement: begin transaction isolation level serializable;
 statement: insert into selfconflict values (3,1), (3,2) on conflict do nothing;
 statement: commit;
 statement: begin transaction isolation level read committed;
 statement: insert into selfconflict values (4,1), (4,2) on conflict(f1) do update set f2 = 0;
 statement: commit;
 statement: begin transaction isolation level repeatable read;
 statement: insert into selfconflict values (5,1), (5,2) on conflict(f1) do update set f2 = 0;
 statement: commit;
 statement: begin transaction isolation level serializable;
 statement: insert into selfconflict values (6,1), (6,2) on conflict(f1) do update set f2 = 0;
 statement: commit;
 statement: select * from selfconflict;
 statement: drop table selfconflict;
 statement: select message from postgres_log where query is null;

