LOG:  statement: select message from postgres_log where query is null;
 statement: create type complex as (r float8, i float8);
 statement: create temp table fullname (first text, last text);
 statement: create type quad as (c1 complex, c2 complex);
 statement: select (1.1,2.2)::complex, row((3.3,4.4),(5.5,null))::quad;
 statement: select row('Joe', 'Blow')::fullname, '(Joe,Blow)'::fullname;
 statement: select '(Joe,von Blow)'::fullname, '(Joe,d''Blow)'::fullname;
 statement: select '(Joe,"von""Blow")'::fullname, E'(Joe,d\\\\Blow)'::fullname;
 statement: select '(Joe,"Blow,Jr")'::fullname;
 statement: select '(Joe,)'::fullname;
 statement: select '(Joe)'::fullname;
 statement: select '(Joe,,)'::fullname;
 statement: create temp table quadtable(f1 int, q quad);
 statement: insert into quadtable values (1, ((3.3,4.4),(5.5,6.6)));
 statement: insert into quadtable values (2, ((null,4.4),(5.5,6.6)));
 statement: select * from quadtable;
 statement: select f1, q.c1 from quadtable;
 statement: select f1, (q).c1, (qq.q).c1.i from quadtable qq;
 statement: create temp table people (fn fullname, bd date);
 statement: insert into people values ('(Joe,Blow)', '1984-01-10');
 statement: select * from people;
 statement: alter table fullname add column suffix text default '';
 statement: alter table fullname add column suffix text default null;
 statement: select * from people;
 statement: update people set fn.suffix = 'Jr';
 statement: select * from people;
 statement: insert into quadtable (f1, q.c1.r, q.c2.i) values(44,55,66);
 statement: select * from quadtable;
 statement: create temp table pp (f1 text);
 statement: insert into pp values (repeat('abcdefghijkl', 100000));
 statement: insert into people select ('Jim', f1, null)::fullname, current_date from pp;
 statement: select (fn).first, substr((fn).last, 1, 20), length((fn).last) from people;
 statement: select ROW(1,2) < ROW(1,3) as true;
 statement: select ROW(1,2) < ROW(1,1) as false;
 statement: select ROW(1,2) < ROW(1,NULL) as null;
 statement: select ROW(1,2,3) < ROW(1,3,NULL) as true;
 statement: select ROW(11,'ABC') < ROW(11,'DEF') as true;
 statement: select ROW(11,'ABC') > ROW(11,'DEF') as false;
 statement: select ROW(12,'ABC') > ROW(11,'DEF') as true;
 statement: select ROW(1,2,3) < ROW(1,NULL,4) as null;
 statement: select ROW(1,2,3) = ROW(1,NULL,4) as false;
 statement: select ROW(1,2,3) <> ROW(1,NULL,4) as true;
 statement: select ROW('ABC','DEF') ~<=~ ROW('DEF','ABC') as true;
 statement: select ROW('ABC','DEF') ~>=~ ROW('DEF','ABC') as false;
 statement: select ROW('ABC','DEF') ~~ ROW('DEF','ABC') as fail;
 statement: select ROW(1,2) = ROW(1,2::int8);
 statement: select ROW(1,2) in (ROW(3,4), ROW(1,2));
 statement: select ROW(1,2) in (ROW(3,4), ROW(1,2::int8));
 statement: select unique1, unique2 from tenk1                                          +
 where (unique1, unique2) < any (select ten, ten from tenk1 where hundred < 3)          +
       and unique1 <= 20                                                                +
 order by 1;
 statement: explain (costs off)                                                         +
 select thousand, tenthous from tenk1                                                   +
 where (thousand, tenthous) >= (997, 5000)                                              +
 order by thousand, tenthous;
 statement: select thousand, tenthous from tenk1                                        +
 where (thousand, tenthous) >= (997, 5000)                                              +
 order by thousand, tenthous;
 statement: create temp table test_table (a text, b text);
 statement: insert into test_table values ('a', 'b');
 statement: insert into test_table select 'a', null from generate_series(1,1000);
 statement: insert into test_table values ('b', 'a');
 statement: create index on test_table (a,b);
 statement: set enable_sort = off;
 statement: explain (costs off)                                                         +
 select a,b from test_table where (a,b) > ('a','a') order by a,b;
 statement: select a,b from test_table where (a,b) > ('a','a') order by a,b;
 statement: reset enable_sort;
 statement: select * from int8_tbl i8 where i8 in (row(123,456));
 statement: explain (costs off)                                                         +
 select * from int8_tbl i8                                                              +
 where i8 in (row(123,456)::int8_tbl, '(4567890123456789,123)');
 statement: select * from int8_tbl i8                                                   +
 where i8 in (row(123,456)::int8_tbl, '(4567890123456789,123)');
 statement: select ROW();
 statement: select ROW() IS NULL;
 statement: select ROW() = ROW();
 statement: select array[ row(1,2), row(3,4), row(5,6) ];
 statement: select row(1,1.1) = any (array[ row(7,7.7), row(1,1.1), row(0,0.0) ]);
 statement: select row(1,1.1) = any (array[ row(7,7.7), row(1,1.0), row(0,0.0) ]);
 statement: create type cantcompare as (p point, r float8);
 statement: create temp table cc (f1 cantcompare);
 statement: insert into cc values('("(1,2)",3)');
 statement: insert into cc values('("(4,5)",6)');
 statement: select * from cc order by f1;
 statement: BEGIN;
 statement: CREATE TABLE price (                                                        +
     id SERIAL PRIMARY KEY,                                                             +
     active BOOLEAN NOT NULL,                                                           +
     price NUMERIC                                                                      +
 );
 statement: CREATE TYPE price_input AS (                                                +
     id INTEGER,                                                                        +
     price NUMERIC                                                                      +
 );
 statement: CREATE TYPE price_key AS (                                                  +
     id INTEGER                                                                         +
 );
 statement: CREATE FUNCTION price_key_from_table(price) RETURNS price_key AS $$         +
     SELECT $1.id                                                                       +
 $$ LANGUAGE SQL;
 statement: CREATE FUNCTION price_key_from_input(price_input) RETURNS price_key AS $$   +
     SELECT $1.id                                                                       +
 $$ LANGUAGE SQL;
 statement: insert into price values (1,false,42), (10,false,100), (11,true,17.99);
 statement: UPDATE price                                                                +
     SET active = true, price = input_prices.price                                      +
     FROM unnest(ARRAY[(10, 123.00), (11, 99.99)]::price_input[]) input_prices          +
     WHERE price_key_from_table(price.*) = price_key_from_input(input_prices.*);
 statement: select * from price;
 statement: rollback;
 statement: create temp table compos (f1 int, f2 text);
 statement: create function fcompos1(v compos) returns void as $$                       +
 insert into compos values (v);  -- fail                                                +
 $$ language sql;
 statement: create function fcompos1(v compos) returns void as $$                       +
 insert into compos values (v.*);                                                       +
 $$ language sql;
 statement: create function fcompos2(v compos) returns void as $$                       +
 select fcompos1(v);                                                                    +
 $$ language sql;
 statement: create function fcompos3(v compos) returns void as $$                       +
 select fcompos1(fcompos3.v.*);                                                         +
 $$ language sql;
 statement: select fcompos1(row(1,'one'));
 statement: select fcompos2(row(2,'two'));
 statement: select fcompos3(row(3,'three'));
 statement: select * from compos;
 statement: select cast (fullname as text) from fullname;
 statement: select fullname::text from fullname;
 statement: select text(fullname) from fullname;
 statement: select fullname.text from fullname;
 statement: select cast (row('Jim', 'Beam') as text);
 statement: select (row('Jim', 'Beam'))::text;
 statement: select text(row('Jim', 'Beam'));
 statement: select (row('Jim', 'Beam')).text;
 statement: select row_to_json(i) from int8_tbl i;
 statement: select row_to_json(i) from int8_tbl i(x,y);
 statement: create temp view vv1 as select * from int8_tbl;
 statement: select row_to_json(i) from vv1 i;
 statement: select row_to_json(i) from vv1 i(x,y);
 statement: select row_to_json(ss) from                                                 +
   (select q1, q2 from int8_tbl) as ss;
 statement: select row_to_json(ss) from                                                 +
   (select q1, q2 from int8_tbl offset 0) as ss;
 statement: select row_to_json(ss) from                                                 +
   (select q1 as a, q2 as b from int8_tbl) as ss;
 statement: select row_to_json(ss) from                                                 +
   (select q1 as a, q2 as b from int8_tbl offset 0) as ss;
 statement: select row_to_json(ss) from                                                 +
   (select q1 as a, q2 as b from int8_tbl) as ss(x,y);
 statement: select row_to_json(ss) from                                                 +
   (select q1 as a, q2 as b from int8_tbl offset 0) as ss(x,y);
 statement: explain (costs off)                                                         +
 select row_to_json(q) from                                                             +
   (select thousand, tenthous from tenk1                                                +
    where thousand = 42 and tenthous < 2000 offset 0) q;
 statement: select row_to_json(q) from                                                  +
   (select thousand, tenthous from tenk1                                                +
    where thousand = 42 and tenthous < 2000 offset 0) q;
 statement: select row_to_json(q) from                                                  +
   (select thousand as x, tenthous as y from tenk1                                      +
    where thousand = 42 and tenthous < 2000 offset 0) q;
 statement: select row_to_json(q) from                                                  +
   (select thousand as x, tenthous as y from tenk1                                      +
    where thousand = 42 and tenthous < 2000 offset 0) q(a,b);
 statement: create temp table tt1 as select * from int8_tbl limit 2;
 statement: create temp table tt2 () inherits(tt1);
 statement: insert into tt2 values(0,0);
 statement: select row_to_json(r) from (select q2,q1 from tt1 offset 0) r;
 statement: explain (verbose, costs off)                                                +
 select r, r is null as isnull, r is not null as isnotnull                              +
 from (values (1,row(1,2)), (1,row(null,null)), (1,null),                               +
              (null,row(1,2)), (null,row(null,null)), (null,null) ) r(a,b);
 statement: select r, r is null as isnull, r is not null as isnotnull                   +
 from (values (1,row(1,2)), (1,row(null,null)), (1,null),                               +
              (null,row(1,2)), (null,row(null,null)), (null,null) ) r(a,b);
 statement: explain (verbose, costs off)                                                +
 with r(a,b) as                                                                         +
   (values (1,row(1,2)), (1,row(null,null)), (1,null),                                  +
           (null,row(1,2)), (null,row(null,null)), (null,null) )                        +
 select r, r is null as isnull, r is not null as isnotnull from r;
 statement: with r(a,b) as                                                              +
   (values (1,row(1,2)), (1,row(null,null)), (1,null),                                  +
           (null,row(1,2)), (null,row(null,null)), (null,null) )                        +
 select r, r is null as isnull, r is not null as isnotnull from r;

