LOG:  statement: select message from postgres_log where query is null;
 statement: CREATE USER regtest_unpriv_user;
 statement: CREATE SCHEMA temp_func_test;
 statement: GRANT ALL ON SCHEMA temp_func_test TO public;
 statement: SET search_path TO temp_func_test, public;
 statement: CREATE FUNCTION functest_A_1(text, date) RETURNS bool LANGUAGE 'sql'                               +
        AS 'SELECT $1 = ''abcd'' AND $2 > ''2001-01-01''';
 statement: CREATE FUNCTION functest_A_2(text[]) RETURNS int LANGUAGE 'sql'                                    +
        AS 'SELECT $1[0]::int';
 statement: CREATE FUNCTION functest_A_3() RETURNS bool LANGUAGE 'sql'                                         +
        AS 'SELECT false';
 statement: SELECT proname, prorettype::regtype, proargtypes::regtype[] FROM pg_proc                           +
        WHERE oid in ('functest_A_1'::regproc,                                                                 +
                      'functest_A_2'::regproc,                                                                 +
                      'functest_A_3'::regproc) ORDER BY proname;
 statement: CREATE FUNCTION functest_B_1(int) RETURNS bool LANGUAGE 'sql'                                      +
        AS 'SELECT $1 > 0';
 statement: CREATE FUNCTION functest_B_2(int) RETURNS bool LANGUAGE 'sql'                                      +
        IMMUTABLE AS 'SELECT $1 > 0';
 statement: CREATE FUNCTION functest_B_3(int) RETURNS bool LANGUAGE 'sql'                                      +
        STABLE AS 'SELECT $1 = 0';
 statement: CREATE FUNCTION functest_B_4(int) RETURNS bool LANGUAGE 'sql'                                      +
        VOLATILE AS 'SELECT $1 < 0';
 statement: SELECT proname, provolatile FROM pg_proc                                                           +
        WHERE oid in ('functest_B_1'::regproc,                                                                 +
                      'functest_B_2'::regproc,                                                                 +
                      'functest_B_3'::regproc,                                                                 +
                      'functest_B_4'::regproc) ORDER BY proname;
 statement: ALTER FUNCTION functest_B_2(int) VOLATILE;
 statement: ALTER FUNCTION functest_B_3(int) COST 100;
 statement: SELECT proname, provolatile FROM pg_proc                                                           +
        WHERE oid in ('functest_B_1'::regproc,                                                                 +
                      'functest_B_2'::regproc,                                                                 +
                      'functest_B_3'::regproc,                                                                 +
                      'functest_B_4'::regproc) ORDER BY proname;
 statement: CREATE FUNCTION functext_C_1(int) RETURNS bool LANGUAGE 'sql'                                      +
        AS 'SELECT $1 > 0';
 statement: CREATE FUNCTION functext_C_2(int) RETURNS bool LANGUAGE 'sql'                                      +
        SECURITY DEFINER AS 'SELECT $1 = 0';
 statement: CREATE FUNCTION functext_C_3(int) RETURNS bool LANGUAGE 'sql'                                      +
        SECURITY INVOKER AS 'SELECT $1 < 0';
 statement: SELECT proname, prosecdef FROM pg_proc                                                             +
        WHERE oid in ('functext_C_1'::regproc,                                                                 +
                      'functext_C_2'::regproc,                                                                 +
                      'functext_C_3'::regproc) ORDER BY proname;
 statement: ALTER FUNCTION functext_C_1(int) IMMUTABLE;
 statement: ALTER FUNCTION functext_C_2(int) SECURITY INVOKER;
 statement: ALTER FUNCTION functext_C_3(int) SECURITY DEFINER;
 statement: SELECT proname, prosecdef FROM pg_proc                                                             +
        WHERE oid in ('functext_C_1'::regproc,                                                                 +
                      'functext_C_2'::regproc,                                                                 +
                      'functext_C_3'::regproc) ORDER BY proname;
 statement: CREATE FUNCTION functext_E_1(int) RETURNS bool LANGUAGE 'sql'                                      +
        AS 'SELECT $1 > 100';
 statement: CREATE FUNCTION functext_E_2(int) RETURNS bool LANGUAGE 'sql'                                      +
        LEAKPROOF AS 'SELECT $1 > 100';
 statement: SELECT proname, proleakproof FROM pg_proc                                                          +
        WHERE oid in ('functext_E_1'::regproc,                                                                 +
                      'functext_E_2'::regproc) ORDER BY proname;
 statement: ALTER FUNCTION functext_E_1(int) LEAKPROOF;
 statement: ALTER FUNCTION functext_E_2(int) STABLE;
 statement: SELECT proname, proleakproof FROM pg_proc                                                          +
        WHERE oid in ('functext_E_1'::regproc,                                                                 +
                      'functext_E_2'::regproc) ORDER BY proname;
 statement: ALTER FUNCTION functext_E_2(int) NOT LEAKPROOF;
 statement: SELECT proname, proleakproof FROM pg_proc                                                          +
        WHERE oid in ('functext_E_1'::regproc,                                                                 +
                      'functext_E_2'::regproc) ORDER BY proname;
 statement: ALTER FUNCTION functext_E_1(int) OWNER TO regtest_unpriv_user;
 statement: ALTER FUNCTION functext_E_2(int) OWNER TO regtest_unpriv_user;
 statement: SET SESSION AUTHORIZATION regtest_unpriv_user;
 statement: SET search_path TO temp_func_test, public;
 statement: ALTER FUNCTION functext_E_1(int) NOT LEAKPROOF;
 statement: ALTER FUNCTION functext_E_2(int) LEAKPROOF;
 statement: CREATE FUNCTION functext_E_3(int) RETURNS bool LANGUAGE 'sql'                                      +
        LEAKPROOF AS 'SELECT $1 < 200';
 statement: RESET SESSION AUTHORIZATION;
 statement: CREATE FUNCTION functext_F_1(int) RETURNS bool LANGUAGE 'sql'                                      +
        AS 'SELECT $1 > 50';
 statement: CREATE FUNCTION functext_F_2(int) RETURNS bool LANGUAGE 'sql'                                      +
        CALLED ON NULL INPUT AS 'SELECT $1 = 50';
 statement: CREATE FUNCTION functext_F_3(int) RETURNS bool LANGUAGE 'sql'                                      +
        RETURNS NULL ON NULL INPUT AS 'SELECT $1 < 50';
 statement: CREATE FUNCTION functext_F_4(int) RETURNS bool LANGUAGE 'sql'                                      +
        STRICT AS 'SELECT $1 = 50';
 statement: SELECT proname, proisstrict FROM pg_proc                                                           +
        WHERE oid in ('functext_F_1'::regproc,                                                                 +
                      'functext_F_2'::regproc,                                                                 +
                      'functext_F_3'::regproc,                                                                 +
                      'functext_F_4'::regproc) ORDER BY proname;
 statement: ALTER FUNCTION functext_F_1(int) IMMUTABLE;
 statement: ALTER FUNCTION functext_F_2(int) STRICT;
 statement: ALTER FUNCTION functext_F_3(int) CALLED ON NULL INPUT;
 statement: SELECT proname, proisstrict FROM pg_proc                                                           +
        WHERE oid in ('functext_F_1'::regproc,                                                                 +
                      'functext_F_2'::regproc,                                                                 +
                      'functext_F_3'::regproc,                                                                 +
                      'functext_F_4'::regproc) ORDER BY proname;
 statement: CREATE FUNCTION functest_IS_1(a int, b int default 1, c text default 'foo')                        +
     RETURNS int                                                                                               +
     LANGUAGE SQL                                                                                              +
     AS 'SELECT $1 + $2';
 statement: CREATE FUNCTION functest_IS_2(out a int, b int default 1)                                          +
     RETURNS int                                                                                               +
     LANGUAGE SQL                                                                                              +
     AS 'SELECT $1';
 statement: CREATE FUNCTION functest_IS_3(a int default 1, out b int)                                          +
     RETURNS int                                                                                               +
     LANGUAGE SQL                                                                                              +
     AS 'SELECT $1';
 statement: SELECT routine_name, ordinal_position, parameter_name, parameter_default                           +
     FROM information_schema.parameters JOIN information_schema.routines USING (specific_schema, specific_name)+
     WHERE routine_schema = 'temp_func_test' AND routine_name ~ '^functest_is_'                                +
     ORDER BY 1, 2;
 statement: DROP SCHEMA temp_func_test CASCADE;
 statement: DROP USER regtest_unpriv_user;
 statement: RESET search_path;

